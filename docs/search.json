[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to quantitative analysis with R",
    "section": "",
    "text": "Welcome!\nWelcome to the Introduction to Quantitative Analysis with R course, designed for and with the Ministry of Housing, Communities and Local Government (MHCLG). This course aims to introduce R and RStudio software. R is an open-source software that was designed to make data analysis more accessible, reproducible, and user friendly.\nThis two-day course will equip you with the essential skills to leverage the power of R for your data analysis. We will begin with a gentle introduction to the RStudio interface and the basics of the R coding language (or syntax). We will then see how R can be used to efficiently load, clean and transform data. Finally, we will use R to produce clear, compelling visualisations and tables to communicate findings.\nThroughout the course, we will discuss best practices for reproducible data analysis, ensuring that all code adheres to the Analysis Standards as recommended by the Aqua book.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#how-to-use-these-materials",
    "href": "index.html#how-to-use-these-materials",
    "title": "Introduction to quantitative analysis with R",
    "section": "How to use these materials",
    "text": "How to use these materials\nThis e-book provides a combination of written explanations, code examples, and practical exercises to allow you to practice what you have learned.\n\n1 + 1\n\nCode within these blocks can be copied and pasted into your R session to save time when coding (I recommend typing the code yourself to familiarise yourself with the coding process and use the copy option if you are really stuck!).\nThroughout the materials, you will see colour-coded boxes which are used to highlight important points, give warnings, or give tips such as keyboard shortcuts.\n\n\n\n\n\n\nNote\n\n\n\nThese boxes will be used to highlight important messages, supplementing the main text.\n\n\n\n\n\n\n\n\nHint\n\n\n\nThese boxes will contain useful hints, such as keyboard shortcuts, that can make your coding life a little easier!\n\n\n\n\n\n\n\nStyle tip\n\n\nThese boxes contain style tips to ensure that your code follows the Tidyverse style guide, making it as consistent and readable as possible.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThese boxes will contain warnings and highlight areas where you need to be more cautious in your coding or analysis.\n\n\nTo make these notes as accessible as possible, they are available to view in dark mode by toggling the  button. They are also available to download as a PDF file using the  button.\nAll exercise solutions are available in the appendices. Please attempt the exercises yourself first, making full use of R’s built in help files, cheatsheets and example R code in this book. Going straight to the solutions to copy and paste the code without thinking will not help you after the course!\nSome exercises contain expandable hints, such as functions required to complete them, that can be viewed when needed. For example:\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nThe functions you will need for this exercise are filter and count.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "index.html#data-for-the-course",
    "href": "index.html#data-for-the-course",
    "title": "Introduction to quantitative analysis with R",
    "section": "Data for the course",
    "text": "Data for the course\nThis course uses data from the English Housing Survey (EHS) from 2021 and the Office for Budget Responsibility (OBR) 2024 economic and fiscal outlook. All data used in the course can be downloaded from the course repository.\nBefore beginning the course, please save these files into a folder called ‘data’ within the folder you will be working from during the course.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "1  Introduction to RStudio",
    "section": "",
    "text": "1.1 The RStudio console window\nThe screenshot below shows the RStudio interface which comprises of four windows:",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to RStudio</span>"
    ]
  },
  {
    "objectID": "01_intro.html#the-rstudio-console-window",
    "href": "01_intro.html#the-rstudio-console-window",
    "title": "1  Introduction to RStudio",
    "section": "",
    "text": "RStudio console window\n\n\n\n1.1.1 Window A: R script files\nAll analysis and actions in R are carried out using the R syntax language. R script files allow us to write and edit code before running it in the console window.\n\n\n\n\n\nStyle tip\n\n\nLimit script files to 80 characters per line to ensure it is readable.\nRStudio has an option to add a margin that makes this easier to adhere to. Under the Tools drop-down menu, select Global options. Select Code from the list on the right, then under the Display tab, tick the Show margin box.\n\n\nIf this window is not visible, create a new script file using File -&gt; New File -&gt; R Script option from the drop-down menus or clicking the  icon above the console and selecting ‘R Script’. This will open a new, blank script file. More than one script file can be open at the same time.\nCode entered into the script file does not run automatically. To run commands, highlight the code from the script file and click the  icon above the top right corner of the script window (this can be carried out by pressing Ctrl + Enter in Windows or Command + Enter on a Mac computer). Multiple lines of code can be run at once.\nThe main advantage of using the script file rather than entering the code directly into the console is that it can be saved, edited and shared. To save a script file, use File -&gt; Save As… from the drop down menu, click the  icon at the top of the window, or use the keyboard shortcut ctrl + s for Windows and command + s for Mac. It is important to save the script files at regular intervals to avoid losing work.\n\n\n\n\n\nStyle tip\n\n\nScript file names should be meaningful, lower case, and end in .R. Avoid using special characters in file names, including spaces. Use _ instead of spaces.\nWhere files should be run in a specific order, prefix the file name with numbers.\n\n\nPast script files can be opened using File -&gt; Open File… from the drop-down menu, by clicking the  icon, or using the keyboard shortcut ctrl + o for Windows and command + o for Mac, then selecting a *.R file.\n\n\n1.1.2 Window B: R console\nThe R console window is where all commands run from the script file, results (other than plots), and messages, such as errors, are displayed. Commands can be written directly into the R console after the &gt; symbol and executed using Enter on the keyboard. It is not recommended to write code directly into the console as it is cannot be saved or replicated.\nEvery time a new R session is opened, details about version and citations of R will be given by default. To clear text from the console window, use the keyboard shortcut control + l (this is the same for both Windows and Mac users). Be aware that this clears all text from the console, including any results. Before running this command, check that any results can be replicated within the script file.\n\n\n1.1.3 Window C: Environment and history\nThis window lists all data and objects currently loaded into R, and is not available in the basic R software. More details on the types of objects and how to use the Environment window are given in later sections.\n\n\n1.1.4 Window D: Files, plots, packages and help\nThis window has many potential uses: plots are displayed and can be saved from here, and R help files will appear here. This window is only available in the RStudio interface and not in the basic R package.",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to RStudio</span>"
    ]
  },
  {
    "objectID": "01_intro.html#exercise-1",
    "href": "01_intro.html#exercise-1",
    "title": "1  Introduction to RStudio",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nOpen a new script file if you have not already done so.\nSave this script file into an appropriate location.",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to RStudio</span>"
    ]
  },
  {
    "objectID": "02_syntax.html",
    "href": "02_syntax.html",
    "title": "2  R syntax",
    "section": "",
    "text": "Exercise 2\nFor each part of question 2, copy the result from the console and paste them onto the same line of the script file as the code. Do this in a way that ensures there are no error messages if you were to run the entire script file.",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R syntax</span>"
    ]
  },
  {
    "objectID": "02_syntax.html#exercise-2",
    "href": "02_syntax.html#exercise-2",
    "title": "2  R syntax",
    "section": "",
    "text": "Add your name and the date to the top of your script file (hint: comment this out so R does not try to run it)\nUse R to answer to following sums:\n\n\n\\(64^2\\)\n\\(3432 \\div 8\\)\n\\(96 \\times 72\\)\n\n\n\n\n\n\n\n\nHint\n\n\n\nTo run a script file from beginning to end, select all code using ctrl + a/Cmnd + a, then run the selected code as usual.",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R syntax</span>"
    ]
  },
  {
    "objectID": "03_objects_functions.html",
    "href": "03_objects_functions.html",
    "title": "3  R objects, functions and packages",
    "section": "",
    "text": "3.1 Objects\nOne of the main advantages to using R over other software packages such as SPSS is that more than one dataset can be accessed at the same time. A collection of data stored in any format within the R session is known as an object. Objects can include single numbers, single variables, entire datasets, lists of datasets, or even tables and graphs.\nObjects are defined in R using the &lt;- symbol or =. For example,\nobject_1 &lt;- 81\nCreates an object in the environment named object_1, which takes the value 81. This will appear in the environment window of the console (window C from the interface shown in Section 1.1.3).\nTo retrieve an object, type its name into the script or console and run it. This object can then be included in functions or operations in place of the value assigned to it:\nobject_1\n\n[1] 81\n\nsqrt(object_1)\n\n[1] 9\nR has some mathematical objects stored by default such as pi that can be used in calculations.\npi\n\n[1] 3.141593",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R objects, functions and packages</span>"
    ]
  },
  {
    "objectID": "03_objects_functions.html#objects",
    "href": "03_objects_functions.html#objects",
    "title": "3  R objects, functions and packages",
    "section": "",
    "text": "Style tip\n\n\nObject names should only contain lower case letters, numbers and _ (instead of a space to separate words). They should be meaningful and concise.\n\n\n\n\n\n\n\n\n\n\nStyle tip\n\n\nAlthough both work, use &lt;- for assignment, not =.",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R objects, functions and packages</span>"
    ]
  },
  {
    "objectID": "03_objects_functions.html#functions",
    "href": "03_objects_functions.html#functions",
    "title": "3  R objects, functions and packages",
    "section": "3.2 Functions",
    "text": "3.2 Functions\nFunctions are built-in commands that allow R users to run analyses. All functions require the definition of arguments within round brackets (). Each function requires different information and has different arguments that can be used to customise the analysis. A detailed list of these arguments and a description of the function can be found in the function’s associated help file.\n\n3.2.1 Help files\nEach function that exists within R has an associated help file. RStudio does not require an internet connection to access these help files if the function is available in the current session of R.\nTo retrieve help files, enter ? followed by the function name into the console window, e.g ?mean. The help file will appear in window D of the interface shown in Section 1.1.4.\nHelp files contain the following information:\n\nDescription: what the function is used for\nUsage: how the function is used\nArguments: required and optional arguments entered into round brackets necessary for the function to work\nDetails: relevant details about the function in question\nReferences\nSee also: links to other relevant functions\nExamples: example code with applications of the function\n\n\n\n\n\n\n\nHint\n\n\n\nIf you know the arguments required in a function are different to default settings, but are not totally sure the settings you require, consider running example code from the helpfile in the console and seeing how these arguments change the process.\n\n\n\n\n3.2.2 Error and warning messages\nWhere a function or object has not been correctly specified, or their is some mistake in the syntax that has been sent to the console, R will return an error message. These messages are generally informative and include the location of the error.\nThe most common errors include misspelling functions or objects:\n\nsqrt(ojbect_1)\n\nError in eval(expr, envir, enclos): object 'ojbect_1' not found\n\nSqrt(object_1)\n\nError in Sqrt(object_1): could not find function \"Sqrt\"\n\n\nOr where an object has not yet been specified:\n\nplot(x, y)\n\nError in eval(expr, envir, enclos): object 'x' not found\n\n\nWhen R returns an error message, this means that the operation has been completely halted. R may also return warning messages which look similar to errors but does not necessarily mean the operation has been stopped.\nWarnings are included to indicate that R suspects something in the operation may be wrong and should be checked. There are occasions where warnings can be ignored but this is only after the operation has been checked.\n\n\n3.2.3 Cleaning the environment\nTo remove objects from the RStudio environment, we can use the rm function. This can be combined with the ls() function, which lists all objects in the environment, to remove all objects currently loaded:\n\nrm(list = ls())\n\n\n\n\n\n\n\nWarning\n\n\n\nThere are no undo and redo buttons for R syntax. The rm function will permanently delete objects from the environment. The only way to reverse this is to re-run the code that created the objects originally from the script file.",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R objects, functions and packages</span>"
    ]
  },
  {
    "objectID": "03_objects_functions.html#packages",
    "href": "03_objects_functions.html#packages",
    "title": "3  R objects, functions and packages",
    "section": "3.3 Packages",
    "text": "3.3 Packages\nR packages are a collection of functions and datasets developed by R users that expand existing R capabilities or add completely new ones. Packages allow users to apply the most up-to-date methods shortly after they are developed, unlike other statistical software packages that require an entirely new version.\n\n3.3.1 Installing packages from CRAN\nThe quickest way to install a package in R is by using the install.packages function. This sends RStudio to the online repository of tested and verified R packages (known as CRAN) and downloads the package files onto the machine you are currently working from in temporary files. Ensure that the package you wish to install is spelled correctly and surrounded by ''.\n\n\n\n\n\n\nWarning\n\n\n\nThe install.packages function requires an internet connection, and can take a long time if the package has a lot of dependent packages that also need downloading.\nThis process should only be carried out the first time a package is used on a machine, or when a substantial update has taken place, to download the latest version of the package.\n\n\n\n\n3.3.2 Loading packages to an R session\nEvery time a new session of RStudio is opened, packages must be reloaded. To load a package into R (and gain access to the associated functions and data), use the library function.\nLoading a package does not require an internet connection, but will only work if the package has already been installed and saved onto the computer you are working from. If you are unsure, use the function installed.packages to return a list of all packages that are loaded onto the machine you are working from.\n\n\n\n\n\nStyle tip\n\n\nBegin any script file that requires packages by loading them into the current session. This ensures that there will be no error messages from functions that are not available in the current session.\n\n\n\n\n3.3.3 The pacman package\nThe pacman package is a set of package management functions which is designed to make tasks such as installing and loading packages simpler, and speeds up these processes. There are lots of useful functions included in this package, but the one that we will be using in this course is p_load.\np_load acts as a wrapper for the library function. It first checks the computer to see whether the package(s) listed is installed. If they are, p_load loads the package(s) into the current RStudio session. If not, it attempts to install the package(s) from the CRAN repository.\nIf you have never used the pacman package before, run the following code to ensure that it is installed on your machine:\n\ninstall.packages('pacman')",
    "crumbs": [
      "Introduction to R and RStudio",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R objects, functions and packages</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html",
    "href": "04_open_explore_data.html",
    "title": "4  Opening and exploring data",
    "section": "",
    "text": "4.1 Styles of R coding\nUp to this point, beyond the style tips sprinkled through these notes, we have not thought about the style of R coding we will be using. There are different approaches to R coding that we can use, they can be thought of as different dialects of the R programming language.\nThe choice of R ‘dialect’ depends on personal preference. Some prefer to use the ‘base R’ approach that does not rely on any packages that may need updating, making it a more stable approach. However, base R can be difficult to read for those not comfortable with coding.\nThe alternative approach that we will be adopting in this course is the ‘tidyverse’ approach. Tidyverse is a set of packages that have been designed to make R coding more readable and efficient. They have been designed with reproducibility in mind, which means there is a wealth of online (mostly free), well-written resources available to help use these packages. Tidyverse is also the preferred coding style of the Government Analysis Function guidance.\nIf you have not done so already, install the tidyverse packages to your machine using the following code:\ninstall.packages('tidyverse')\nOnce the tidyverse package is installed, we must load it into the current working session. At the beginning of your script file add the following syntax:\npacman::p_load(tidyverse)",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#styles-of-r-coding",
    "href": "04_open_explore_data.html#styles-of-r-coding",
    "title": "4  Opening and exploring data",
    "section": "",
    "text": "Warning\n\n\n\nThis can take a long time if you have never downloaded the tidyverse packages before as there are many dependencies that are required.\nDo not stress if you get a lot of text in the console! This is normal, but watch out for any error messages.\n\n\n\n\n\n\n\n\n\nStyle tip\n\n\nThe double colon in R can be used to run a function within an installed package without loading the entire package to an R session.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#the-working-directory",
    "href": "04_open_explore_data.html#the-working-directory",
    "title": "4  Opening and exploring data",
    "section": "4.2 The working directory",
    "text": "4.2 The working directory\nThe working directory is a file path on your computer that R sets as the default location when opening, saving, or exporting documents, files, and graphics. This file path can be specified manually but setting the working directory saves time and makes code more efficient.\nThe working directory can be set manually by using the Session -&gt; Set Working Directory -&gt; Change Directory… option from the drop-down menu, or the setwd function. Both options require the directory to be specified each time R is restarted, are sensitive to changes in folders within the file path, and cannot be used when script files are shared between colleagues.\nAn alternative approach that overcomes all these issues is to create an R project.\n\n4.2.1 R projects\nR projects are files (saved with the .Rproj extension) that keep associated files (including scripts, data, and outputs) grouped together. An R project automatically sets the working directory relative to its current location, which makes collaborative work easier, and avoids issues when a file path is changed.\nProjects are created by using the File -&gt; New project option from the drop-down menu, or using the  icon from the top-right corner of the RStudio interface. Existing projects can be opened under the File -&gt; Open project… drop-down menu or using the project icon.\nWhen creating a new project, we must choose whether we are creating a new directory or using an existing one. Usually, we will have already set up a folder containing data or other documents related to the analysis we plan to carry out. If this is the case, we are using an existing directory and selecting the analysis folder as the project directory.\n\n\n\n\n\nStyle tip\n\n\nHave a clear order to your analysis folder. Consider creating separate folders within a project for input and output data, documentation, and outputs such as graphs or tables.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#loading-data",
    "href": "04_open_explore_data.html#loading-data",
    "title": "4  Opening and exploring data",
    "section": "4.3 Loading data",
    "text": "4.3 Loading data\nTo ensure our code is collaborative and reproducible, we should strive to store data in formats that can be used across multiple platforms. One of the best ways to do this is to store data as a comma-separated file (.csv). CSV files can be opened by a range of different softwares (including R, SPSS, STATA and excel), and base R can be used to open these files without requiring additional packages.\nUnfortunately, we are not always able to choose the format that data are stored in. For example, the English Housing Survey (EHS) data is stored as a .sav (SPSS) data file. Fortunately for us, R has a wide range of packages that have been developed to load data from every conceivable format.\nThe package that we will be using the load SPSS data is the haven package. To ensure this is loaded in at the beginning of each session, adapt the previous p_load function:\n\npacman::p_load(tidyverse, haven)\n\nTo avoid any errors arising from spelling mistakes, we can use the list.files function, which returns a list of files and folders from the current working directory. The file names can be copied from the console and pasted into the script file. As the data are saved in a folder within the working directory, we add the argument path = to specify the folder we want to list files from.\n\nlist.files(path = \"data\")\n\n[1] \"Detailed_forecast_tables_Economy_March_2024.xlsx\"\n[2] \"generalfs21_EUL.sav\"                             \n[3] \"interviewfs21_EUL.sav\"                           \n\n\nThe first data set we will load is thegeneralfs21_EUL.sav file. This contains general information taken from the English Housing Survey (EHS) from 2021, including a unique identifier, the respondents’ region, and the tenure type.\nThe EHS data can be loaded into R using the read_spss function, and saved as an object using the &lt;- symbol:\n\nehs_general &lt;- read_spss(file = \"data/generalfs21_EUL.sav\")\n\nThe imported data will appear in the environment with its given name. The contents of the object can be viewed by clicking on the object name in the environment, opening a tab next to script files. This window is a preview so cannot be edited here.\nSome useful functions that can be used to explore a dataset include:\n\n1names(ehs_general)\n\n2head(ehs_general)\n\n3tail(ehs_general)\n\n4str(ehs_general)\n\n\n1\n\nReturn variable names\n\n2\n\nReturns the first 6 rows\n\n3\n\nReturns the last 6 rows\n\n4\n\nGives information about the structure of an object (including variable types)\n\n\n\n\n[1] \"serialanon\" \"aagfh21\"    \"paired\"     \"tenure8x\"   \"tenure4x\"  \n[6] \"tenure2x\"   \"gorehs\"     \"region3x\"   \"govreg1\"   \n# A tibble: 6 × 9\n  serialanon  aagfh21   paired      tenure8x tenure4x tenure2x gorehs   region3x\n  &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;   &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt;\n1 20220000001 3934.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv…  7 [Eas… 3 [Rest…\n2 20220000005 1580.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest…\n3 20220000006 3360.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv…  6 [Wes… 3 [Rest…\n4 20220000012 1368.     0 [Not pai… 1 [owne… 1 [owne… 1 [Priv…  5 [Eas… 3 [Rest…\n5 20220000013 9847.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest…\n6 20220000017 3262.     0 [Not pai… 1 [owne… 1 [owne… 1 [Priv…  6 [Wes… 3 [Rest…\n# ℹ 1 more variable: govreg1 &lt;dbl+lbl&gt;\n# A tibble: 6 × 9\n  serialanon  aagfh21   paired      tenure8x tenure4x tenure2x gorehs   region3x\n  &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;   &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt;\n1 20220031393  262.     0 [Not pai… 3 [loca… 3 [loca… 2 [Soci…  7 [Eas… 3 [Rest…\n2 20220031396 5741.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv…  6 [Wes… 3 [Rest…\n3 20220031401 1579.     0 [Not pai… 1 [owne… 1 [owne… 1 [Priv…  6 [Wes… 3 [Rest…\n4 20220031402 2178.     0 [Not pai… 1 [owne… 1 [owne… 1 [Priv…  9 [Sou… 2 [Lond…\n5 20220031408 1133.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest…\n6 20220031409 1879.     1 [Paired]  1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest…\n# ℹ 1 more variable: govreg1 &lt;dbl+lbl&gt;\ntibble [9,752 × 9] (S3: tbl_df/tbl/data.frame)\n $ serialanon: dbl+lbl [1:9752] 2.02e+10, 2.02e+10, 2.02e+10, 2.02e+10, 2.02e+10, 2.0...\n   ..@ label        : chr \"Key variable: unique archived identifier\"\n   ..@ format.spss  : chr \"F11.0\"\n   ..@ display_width: int 13\n   ..@ labels       : Named num [1:2] -9 -8\n   .. ..- attr(*, \"names\")= chr [1:2] \"Does not apply\" \"No Answer\"\n $ aagfh21   : dbl+lbl [1:9752] 3934, 1580, 3360, 1368, 9847, 3262, 6584,  389, 4193,...\n   ..@ label        : chr \"Household weight 2021\"\n   ..@ format.spss  : chr \"F8.2\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:2] -9 -8\n   .. ..- attr(*, \"names\")= chr [1:2] \"Does not apply\" \"No answer\"\n $ paired    : dbl+lbl [1:9752] 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1,...\n   ..@ label      : chr \"Whether paired sample case\"\n   ..@ format.spss: chr \"F3.0\"\n   ..@ labels     : Named num [1:4] -9 -8 0 1\n   .. ..- attr(*, \"names\")= chr [1:4] \"Does not apply\" \"No Answer\" \"Not paired\" \"Paired\"\n $ tenure8x  : dbl+lbl [1:9752] 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 4, 1, 4, 1, 1, 2, 4,...\n   ..@ label        : chr \"Tenure with vacancy\"\n   ..@ format.spss  : chr \"F2.0\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:10] -9 -8 1 2 3 4 5 6 7 8\n   .. ..- attr(*, \"names\")= chr [1:10] \"Does not apply\" \"No Answer\" \"owner occupied - occupied\" \"private rented - occupied\" ...\n $ tenure4x  : dbl+lbl [1:9752] 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 4, 1, 4, 1, 1, 2, 4,...\n   ..@ label        : chr \"Tenure\"\n   ..@ format.spss  : chr \"F2.0\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:6] -9 -8 1 2 3 4\n   .. ..- attr(*, \"names\")= chr [1:6] \"Does not apply\" \"No Answer\" \"owner occupied\" \"private rented\" ...\n $ tenure2x  : dbl+lbl [1:9752] 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 2,...\n   ..@ label        : chr \"Tenure\"\n   ..@ format.spss  : chr \"F2.0\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:4] -9 -8 1 2\n   .. ..- attr(*, \"names\")= chr [1:4] \"Does not apply\" \"No Answer\" \"Private\" \"Social\"\n $ gorehs    : dbl+lbl [1:9752]  7, 10,  6,  5, 10,  6,  4, 10,  7,  2, 10,  2,  2,  ...\n   ..@ label      : chr \"Government Office Region EHS version\"\n   ..@ format.spss: chr \"F2.0\"\n   ..@ labels     : Named num [1:11] -9 -8 1 2 4 5 6 7 8 9 ...\n   .. ..- attr(*, \"names\")= chr [1:11] \"Does not apply\" \"No answer\" \"North East\" \"North West\" ...\n $ region3x  : dbl+lbl [1:9752] 3, 3, 3, 3, 3, 3, 1, 3, 3, 1, 3, 1, 1, 3, 1, 2, 3, 1,...\n   ..@ label        : chr \"Overall region of England\"\n   ..@ format.spss  : chr \"F2.0\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:5] -9 -8 1 2 3\n   .. ..- attr(*, \"names\")= chr [1:5] \"Does not apply\" \"No Answer\" \"Northern regions\" \"London and South East regions\" ...\n $ govreg1   : dbl+lbl [1:9752] 4, 4, 2, 2, 4, 2, 1, 4, 4, 1, 4, 1, 1, 2, 1, 4, 4, 1,...\n   ..@ label        : chr \"Government office Region, grouped\"\n   ..@ format.spss  : chr \"F2.0\"\n   ..@ display_width: int 9\n   ..@ labels       : Named num [1:6] -9 -8 1 2 3 4\n   .. ..- attr(*, \"names\")= chr [1:6] \"Does not apply\" \"No Answer\" \"North\" \"Midlands\" ...\n - attr(*, \"notes\")= chr [1:6] \"This third delivery file (interviewfs21.sav)\" \"was updated on 29/11/22\" \"   (Entered 01-Dec-2022)\" \"This third delivery file (interviewfs21.sav)\" ...\n\n\nThe str function tells us that this object is a tibble. This is tidyverse language for a data set (in base R, it is known as a data.frame). All variables are recognised as dbl + lbl, or labelled double variables. Double is tidyverse language for numeric data, and labels are taken from the original SPSS data.\nIt is important to check that R has correctly recognised variable type when data are loaded, before generating any visualisations or analysis. If variables are incorrectly specified, this could either lead to errors or invalid analyses. We will see how to change variables types later in this chapter.\nThe variables in this tibble contain additional information, stored as attributes. Data imported from other sources do not typically include these attributes by default, but these are able to uphold any information that was stored in the ‘Variable view’ window of SPSS.\n\n\n\n\n\n\nHint\n\n\n\nTo remove any of the attributes imported from an SPSS file, we can use haven packages zap functions. For example, zap_widths(x) would remove the width attributes from an object x, and zap_labels(x) would remove value labels. For more information, see this article.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#selecting-variables",
    "href": "04_open_explore_data.html#selecting-variables",
    "title": "4  Opening and exploring data",
    "section": "4.4 Selecting variables",
    "text": "4.4 Selecting variables\nOften, we will not need every variable in a downloaded dataset to carry out an analysis, and we may wish to create a smaller analysis tibble. We may also wish to select individual variables from the tibble to apply functions to them without including the entire dataset.\nTo select one or more variable and return them as a new tibble, we can use the select function from tidyverse’s dplyr package.\nFor example, we do not need all the variables contained in the EHS general dataset. The variables we are interested in keeping are the unique identifier variables (serialanon), the survey weights (aagfh21), the tenure type response with 4 options (tenure4x), and the Government office region (govreg1):\n\n1select(ehs_general, serialanon, aagfh21, tenure4x, gorehs)\n\n2select(ehs_general, 1, 2, 5, 7)\n\n\n1\n\nVariables can be selected using their names\n\n2\n\nOr their column number\n\n\n\n\n# A tibble: 9,752 × 4\n   serialanon  aagfh21   tenure4x           gorehs                       \n   &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;          &lt;dbl+lbl&gt;                    \n 1 20220000001 3934.     1 [owner occupied]  7 [East]                    \n 2 20220000005 1580.     1 [owner occupied] 10 [South West]              \n 3 20220000006 3360.     1 [owner occupied]  6 [West Midlands]           \n 4 20220000012 1368.     1 [owner occupied]  5 [East Midlands]           \n 5 20220000013 9847.     1 [owner occupied] 10 [South West]              \n 6 20220000017 3262.     1 [owner occupied]  6 [West Midlands]           \n 7 20220000022 6584.     1 [owner occupied]  4 [Yorkshire and the Humber]\n 8 20220000025  389.     1 [owner occupied] 10 [South West]              \n 9 20220000026 4193.     2 [private rented]  7 [East]                    \n10 20220000027 3589.     1 [owner occupied]  2 [North West]              \n# ℹ 9,742 more rows\n# A tibble: 9,752 × 4\n   serialanon  aagfh21   tenure4x           gorehs                       \n   &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;          &lt;dbl+lbl&gt;                    \n 1 20220000001 3934.     1 [owner occupied]  7 [East]                    \n 2 20220000005 1580.     1 [owner occupied] 10 [South West]              \n 3 20220000006 3360.     1 [owner occupied]  6 [West Midlands]           \n 4 20220000012 1368.     1 [owner occupied]  5 [East Midlands]           \n 5 20220000013 9847.     1 [owner occupied] 10 [South West]              \n 6 20220000017 3262.     1 [owner occupied]  6 [West Midlands]           \n 7 20220000022 6584.     1 [owner occupied]  4 [Yorkshire and the Humber]\n 8 20220000025  389.     1 [owner occupied] 10 [South West]              \n 9 20220000026 4193.     2 [private rented]  7 [East]                    \n10 20220000027 3589.     1 [owner occupied]  2 [North West]              \n# ℹ 9,742 more rows\n\n\nThe select function can also be combined with a number of ‘selection helper’ functions that help us select variables based on naming conventions:\n\nstarts_with(\"xyz\") returns all variables with names beginning xyz\nends_with(\"xyz\") returns all variables with names ending xyz\ncontains(\"xyz\") returns all variables that have xyz within their name\n\nOr based on whether they match a condition:\n\nwhere(is.numeric) returns all variables that are classed as numeric\n\nFor a full list of these selection helpers, access the helpfile using ?tidyr_tidy_select.\nThe select function can also be used to remove variables from a tibble by adding a - before the variable name or number. For example, to return the EHS general dataset without the unique identifier variable, we use:\n\nselect(ehs_general, -serialanon)\n\n# A tibble: 9,752 × 8\n   aagfh21   paired         tenure8x tenure4x tenure2x gorehs   region3x govreg1\n   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;      &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+lb&gt; &lt;dbl+l&gt;\n 1 3934.     1 [Paired]     1 [owne… 1 [owne… 1 [Priv…  7 [Eas… 3 [Rest… 4 [Res…\n 2 1580.     1 [Paired]     1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest… 4 [Res…\n 3 3360.     1 [Paired]     1 [owne… 1 [owne… 1 [Priv…  6 [Wes… 3 [Rest… 2 [Mid…\n 4 1368.     0 [Not paired] 1 [owne… 1 [owne… 1 [Priv…  5 [Eas… 3 [Rest… 2 [Mid…\n 5 9847.     1 [Paired]     1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest… 4 [Res…\n 6 3262.     0 [Not paired] 1 [owne… 1 [owne… 1 [Priv…  6 [Wes… 3 [Rest… 2 [Mid…\n 7 6584.     0 [Not paired] 1 [owne… 1 [owne… 1 [Priv…  4 [Yor… 1 [Nort… 1 [Nor…\n 8  389.     0 [Not paired] 1 [owne… 1 [owne… 1 [Priv… 10 [Sou… 3 [Rest… 4 [Res…\n 9 4193.     1 [Paired]     2 [priv… 2 [priv… 1 [Priv…  7 [Eas… 3 [Rest… 4 [Res…\n10 3589.     1 [Paired]     1 [owne… 1 [owne… 1 [Priv…  2 [Nor… 1 [Nort… 1 [Nor…\n# ℹ 9,742 more rows\n\n\nAfter making changes to the analysis dataset, it is useful to save this data separately to the original raw data. This can be done using the write_csv function.\n\nehs_general_reduced &lt;- select(ehs_general, serialanon, aagfh21, \n                              tenure4x, gorehs)\n\n\nwrite_csv(ehs_general_reduced, \n          file = \"saved_data/ehs_general_reduced.csv\")\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen saving updated tibbles as files, use a different file name to the original raw data. Using the same name will overwrite the original file. We always want a copy of the original in case of any errors or issues.\n\n\nThe select function returns variables as a tibble object. However, some functions, for example summary functions from base R, require data in the form of a vector. Vectors are lists of values with no formal structure, unlike a tibble which is structured to have rows and columns. To return a single variable as a vector, we can use the $ symbol between the data name and the variable to return:\n\nehs_general_reduced$aagfh21",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#sec-filter",
    "href": "04_open_explore_data.html#sec-filter",
    "title": "4  Opening and exploring data",
    "section": "4.5 Filtering data",
    "text": "4.5 Filtering data\nThe filter function, from tidyverse’s dplyr package allows us to return subgroups of the data based on conditional statements. These conditional statements can include mathematical operators:\n\n&lt;= less than or equal to,\n&lt; less than,\n&gt;= greater than or equal to,\n&gt; greater than,\n== is equal to,\n!= is not equal to,\n\nor can be based on conditional functions:\n\nis.na(variable) where variable is missing,\nbetween(variable, a, b) where variable lies between a and b.\n\nA list of these conditional statements can be found in the help file using ?filter.\nFor example, we may wish to return rows from the EHS dataset that were privately rented. To check which number refers to privately rented, we can check the labels attribute of the tenure4x variable which shows the labels from the SPSS file:\n\nattributes(ehs_general_reduced$tenure4x)$labels\n\n     Does not apply           No Answer      owner occupied      private rented \n                 -9                  -8                   1                   2 \n    local authority housing association \n                  3                   4 \n\n\nPrivate rented is given by a 2 in the current dataset, therefore our conditional statement will return rows where the tenure4x variable takes the value 2.\n\nfilter(ehs_general_reduced, tenure4x == 2)\n\n# A tibble: 1,735 × 4\n   serialanon  aagfh21   tenure4x           gorehs                       \n   &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;          &lt;dbl+lbl&gt;                    \n 1 20220000026 4193.     2 [private rented]  7 [East]                    \n 2 20220000039  423.     2 [private rented]  7 [East]                    \n 3 20220000075 1017.     2 [private rented]  7 [East]                    \n 4 20220000092 1554.     2 [private rented]  7 [East]                    \n 5 20220000113 5254.     2 [private rented]  8 [London]                  \n 6 20220000132 7609.     2 [private rented]  4 [Yorkshire and the Humber]\n 7 20220000134  775.     2 [private rented]  5 [East Midlands]           \n 8 20220000135 1313.     2 [private rented]  1 [North East]              \n 9 20220000187 1528.     2 [private rented]  8 [London]                  \n10 20220000198  557.     2 [private rented] 10 [South West]              \n# ℹ 1,725 more rows\n\n\nMultiple conditional statements can be added to the same function by separating them with a comma , where we want all conditions met, or the | in place of or. To return all respondents that lived in privately rented accommodation in the North East, we can extend the previous filter statement:\n\nattributes(ehs_general_reduced$gorehs)$labels\n\n          Does not apply                No answer               North East \n                      -9                       -8                        1 \n              North West Yorkshire and the Humber            East Midlands \n                       2                        4                        5 \n           West Midlands                     East                   London \n                       6                        7                        8 \n              South East               South West \n                       9                       10 \n\n# North East is region 1\nfilter(ehs_general_reduced, tenure4x == 2, gorehs == 1)\n\n# A tibble: 76 × 4\n   serialanon  aagfh21   tenure4x           gorehs        \n   &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;          &lt;dbl+lbl&gt;     \n 1 20220000135  1313.    2 [private rented] 1 [North East]\n 2 20220001633  3849.    2 [private rented] 1 [North East]\n 3 20220002101  1016.    2 [private rented] 1 [North East]\n 4 20220002817   323.    2 [private rented] 1 [North East]\n 5 20220003959  2800.    2 [private rented] 1 [North East]\n 6 20220004183   636.    2 [private rented] 1 [North East]\n 7 20220005151 10707.    2 [private rented] 1 [North East]\n 8 20220005393  2189.    2 [private rented] 1 [North East]\n 9 20220005697  2059.    2 [private rented] 1 [North East]\n10 20220005754   625.    2 [private rented] 1 [North East]\n# ℹ 66 more rows",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#pipes",
    "href": "04_open_explore_data.html#pipes",
    "title": "4  Opening and exploring data",
    "section": "4.6 Pipes",
    "text": "4.6 Pipes\nWhen creating an analysis-ready dataset, we often want to combine functions such as select and filter. Previously, these would need to be carried out separately and a new object would need to be created or overwritten at each step, clogging up the environment.\nIn tidyverse, we combine functions within a single process using the pipe symbol %&gt;%, which is read as and then within the code. For example, if we wanted to just select the unique identifiers of respondents that were privately renting in the North East, we could do this in a single process:\n\nehs_general_reduced %&gt;% \n  filter(tenure4x == 2, gorehs == 1) %&gt;% \n  select(serialanon)\n\n# A tibble: 76 × 1\n   serialanon \n   &lt;dbl+lbl&gt;  \n 1 20220000135\n 2 20220001633\n 3 20220002101\n 4 20220002817\n 5 20220003959\n 6 20220004183\n 7 20220005151\n 8 20220005393\n 9 20220005697\n10 20220005754\n# ℹ 66 more rows\n\n\n\n\n\n\n\nStyle tip\n\n\nWhen combining multiple functions within a process using pipes, it is good practice to start the code with the data and pipe that into the functions, rather than including it in the function itself.\n\n\n\n\n\n\n\n\nHint\n\n\n\nRather than typing out pipes every time, use the keyboard shortcut ctrl + shift + m for Windows and Command + shift + m for Mac.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#creating-new-variables",
    "href": "04_open_explore_data.html#creating-new-variables",
    "title": "4  Opening and exploring data",
    "section": "4.7 Creating new variables",
    "text": "4.7 Creating new variables\nThe function mutate from tidyverse’s dplyr package allows us to add new variables to a dataset. We can add multiple variables within the same function, separating each with a comma ,.\nThe mutate function is helpful when variable types are not correctly specified by R when they are read in. For example, the region and tenancy type variables in the ehs_general_reduced tibble are categorical variables but are currently recognised as numeric.\nCategorical variables in R are known as factors. These factors can be ordered and can have labels assigned to different levels. To convert an existing variable to a factor, we can use the factor or as_factor functions. Here, we can combine the mutate and as_factor functions to convert tenancy type and region to factors:\n\nehs_general_reduced &lt;- mutate(ehs_general_reduced,\n                              tenancy_type = as_factor(tenure4x),\n                              region = as_factor(gorehs))\n\n\n\n\n\n\n\nNote\n\n\n\nAs this data was taken from an SPSS file that had labels attached to the grouped variables, we do not need to specify these within the as_factor function.\nWhen the variables do not have this labelling structure already, they will need to be added using the label argument of the factor function (see ?factor for more information).\n\n\nThe mutate function can also be used to convert numeric variables into an ordered categorical variable, and can be used to transform variables using mathematical functions. For example, we can create two new variables, first giving the square root of the weighting variable, and second grouping the weighting variable into three categories (low: \\(&lt; 1000\\), medium: \\(1000 \\leq\\) aagfh21 \\(&lt; 5000\\), high: \\(\\geq 5000\\)):\n\nehs_general_reduced &lt;- mutate(ehs_general_reduced,\n                              weighting_sqrt = sqrt(aagfh21),\n                              weighting_fct = cut(aagfh21, \n                                                  breaks = c(0, 1000, \n                                                             5000, Inf),\n                                                  right = TRUE,\n                                                  labels = c(\"Low\", \"Medium\",\n                                                              \"High\")))\n\n\n\n\n\n\n\nHint\n\n\n\nThe c function takes a list of values separated by commas and returns them as a vector. This is useful when a function argument requires multiple values and we don’t want R to move onto the next argument (which is what a comma inside functions usually means).",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#other-useful-dplyr-functions",
    "href": "04_open_explore_data.html#other-useful-dplyr-functions",
    "title": "4  Opening and exploring data",
    "section": "4.8 Other useful dplyr functions",
    "text": "4.8 Other useful dplyr functions\nTo ensure our code follows the tidyverse style guide, variable names should be concise, informative, and contain no special charaters (other than _). The original variable names given in the original EHS data were definitely not stylish! To change names in a dataset, we can use the rename function:\n\nehs_general_reduced &lt;- rename(ehs_general_reduced,\n                              id = serialanon,\n                              weighting = aagfh21)\n\nFor more useful data exploration and manipulation functions from the dplyr package, I would recommending taking a look at the vignette associated with the package (a long-form version of a help file):\nvignette(\"dplyr\")\nOr look at the dplyr web page and cheatsheet.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#a-smooth-process-to-the-analysis-dataset",
    "href": "04_open_explore_data.html#a-smooth-process-to-the-analysis-dataset",
    "title": "4  Opening and exploring data",
    "section": "4.9 A smooth process to the analysis dataset",
    "text": "4.9 A smooth process to the analysis dataset\nOur EHS analysis dataset has been created haphazardly through this chapter to demonstrate each step separately. In reality, we would load this data and manipulate it in one process, separating steps by pipes %&gt;%.\nThe code below takes the data from its saw form (the .sav file) and transforms it into a clean dataset that we will be using for the rest of the course:\n\n1ehs_general_tidy &lt;- read_spss(file = \"Data/generalfs21_EUL.sav\") %&gt;%\n2                    mutate(tenure_type = as_factor(tenure4x),\n                           region = as_factor(gorehs)) %&gt;%\n3                    rename(id = serialanon,\n                           weighting = aagfh21) %&gt;%\n4                    select(id, weighting, tenure_type, region)\n\n5str(ehs_general_tidy)\n\n6write_csv(ehs_general_tidy, file = \"saved_data/ehs_general_tidy.csv\")\n\n\n1\n\nStep 1: load the dataset into R and attach as an object\n\n2\n\nStep 2: convert grouping variables into factors\n\n3\n\nStep 3: rename other variables to avoid confusion\n\n4\n\nStep 4: keep only the necessary variables\n\n5\n\nCheck the new data looks correct\n\n6\n\nStep 5: save this tidy data as a new file in a saved_data folder\n\n\n\n\ntibble [9,752 × 4] (S3: tbl_df/tbl/data.frame)\n $ id         : dbl+lbl [1:9752] 2.02e+10, 2.02e+10, 2.02e+10, 2.02e+10, 2.02e+10, 2.0...\n   ..@ label        : chr \"Key variable: unique archived identifier\"\n   ..@ format.spss  : chr \"F11.0\"\n   ..@ display_width: int 13\n   ..@ labels       : Named num [1:2] -9 -8\n   .. ..- attr(*, \"names\")= chr [1:2] \"Does not apply\" \"No Answer\"\n $ weighting  : dbl+lbl [1:9752] 3934, 1580, 3360, 1368, 9847, 3262, 6584,  389, 4193,...\n   ..@ label        : chr \"Household weight 2021\"\n   ..@ format.spss  : chr \"F8.2\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:2] -9 -8\n   .. ..- attr(*, \"names\")= chr [1:2] \"Does not apply\" \"No answer\"\n $ tenure_type: Factor w/ 6 levels \"Does not apply\",..: 3 3 3 3 3 3 3 3 4 3 ...\n  ..- attr(*, \"label\")= chr \"Tenure\"\n $ region     : Factor w/ 11 levels \"Does not apply\",..: 8 11 7 6 11 7 5 11 8 4 ...\n  ..- attr(*, \"label\")= chr \"Government Office Region EHS version\"\n - attr(*, \"notes\")= chr [1:6] \"This third delivery file (interviewfs21.sav)\" \"was updated on 29/11/22\" \"   (Entered 01-Dec-2022)\" \"This third delivery file (interviewfs21.sav)\" ...",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "04_open_explore_data.html#exercise-3",
    "href": "04_open_explore_data.html#exercise-3",
    "title": "4  Opening and exploring data",
    "section": "Exercise 3",
    "text": "Exercise 3\n\nYou have been provided with another .sav file which contains the interview responses from the EHS. Create and save a tidy version of this dataset, ensuring variables are classified as the correct type and names follow the style conventions (if you cannot remember these, check here for a reminder).\n\nThe variables we need in the tidy dataset are:\n\nThe unique identifier serialanon\nThe gross household income HYEARGRx\nThe length of residence lenresb\nThe weekly rent rentwkx and mortgage mortwkx payments\nWhether the property is freehold or leasehold freeLeas\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nThe functions required for this exercise are read_spss, str, mutate, as_factor, rename.\n\n\n\n\nSave the tidy interview dataset as a csv file with an appropriate file name.\nUsing the new, tidy dataset, answer the following questions:\n\n\nHow many respondents paid weekly rent of between £150 and £300?\nHow many respondents did not give a response to either the weekly rent or weekly mortgage question?\nWhat is the highest household gross income of these responders?\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nThis exercise requires you to create a subgroup which just contains observations that match the condition given (see Section 4.5), and count the number of rows in the subgroup.\nFor the final part, use the max function to return the maximum recorded value. Check that this value actually represents an income.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Opening and exploring data</span>"
    ]
  },
  {
    "objectID": "05_combining_summarising.html",
    "href": "05_combining_summarising.html",
    "title": "5  Combining and summarising datasets",
    "section": "",
    "text": "5.1 Combining multiple datasets\nBoth the SPSS datasets we have been working with so far have contained different information about the English Housing Survey (EHS). We will join these together to create a single analysis dataset with all the information we need.\nFirst we need to reload the tidy datasets we saved previously (now using the read_csv function):\nehs_general_tidy &lt;- read_csv(\"saved_data/ehs_general_tidy.csv\")\nehs_interview_tidy &lt;- read_csv(\"saved_data/ehs_interview_tidy.csv\")\nNotice that by default, the variables that were classed as factors have been recognised by R as chr (character). This is because CSV files are unable to store the grouping attributes that were created in R. Therefore, when we load in CSV files, we need to use the mutate function to re-classify these variables.\nWhen we need to apply the same function to a group of variables within a dataset, the mutate function can be combined with across, which uses selection helpers (see ?dplyr_tidy_select) and retains the original variable names:\nehs_general_tidy &lt;- read_csv(\"saved_data/ehs_general_tidy.csv\") %&gt;% \n  mutate(across(where(is.character), factor))\n\n\nehs_interview_tidy &lt;- read_csv(\"saved_data/ehs_interview_tidy.csv\") %&gt;% \n  mutate(across(where(is.character), factor))\nJoining datasets can be carried out using join functions. There are 4 options we can choose from depending on which observations we want to keep if not all of them are matched (see ?full_join for a full list of options).\nIn this example, we want to keep all observations, even if they are missing from one of the datasets. This requires the full_join function. Both datasets contain a unique identifier which can be included in the full_join function to ensure we are joining like-for-like:\nehs_tidy &lt;- full_join(ehs_general_tidy, ehs_interview_tidy,\n                      by = \"id\") \n\nhead(ehs_tidy)\n\n# A tibble: 6 × 9\n       id weighting tenure_type region gross_income length_residence weekly_rent\n    &lt;dbl&gt;     &lt;dbl&gt; &lt;fct&gt;       &lt;fct&gt;         &lt;dbl&gt; &lt;fct&gt;                  &lt;dbl&gt;\n1 2.02e10     3934. owner occu… East         38378. 20-29 years               NA\n2 2.02e10     1580. owner occu… South…       26525  30+ years                 NA\n3 2.02e10     3360. owner occu… West …       25272. 10-19 years               NA\n4 2.02e10     1368. owner occu… East …       51280. 3-4 years                 NA\n5 2.02e10     9847. owner occu… South…       14365  30+ years                 NA\n6 2.02e10     3262. owner occu… West …       38955  30+ years                 NA\n# ℹ 2 more variables: weekly_mortgage &lt;dbl&gt;, freehold_leasehold &lt;fct&gt;",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Combining and summarising datasets</span>"
    ]
  },
  {
    "objectID": "05_combining_summarising.html#combining-multiple-datasets",
    "href": "05_combining_summarising.html#combining-multiple-datasets",
    "title": "5  Combining and summarising datasets",
    "section": "",
    "text": "Style tip\n\n\nWhen writing script files, we want our code to be as concise and efficient as possible. Although we could use mutate to apply the factor function to each of the categorical variables, using the wrapper across reduces the amount of code needed and, consequently, the risk of errors.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Combining and summarising datasets</span>"
    ]
  },
  {
    "objectID": "05_combining_summarising.html#summarising-data",
    "href": "05_combining_summarising.html#summarising-data",
    "title": "5  Combining and summarising datasets",
    "section": "5.2 Summarising data",
    "text": "5.2 Summarising data\nSummary tables can be created using the summarise function. This returns tables in a tibble format, meaning they can easily be customised and exported as CSV files (using the write_csv function).\nThe summarise function is set up similarly to the mutate function: summaries are listed and given variable names, separated by a comma. The difference between these functions is that summarise collapses the tibble into a single summary, and the new variables must be created using a summary function.\nCommon examples of summary functions include:\n\nmean: a measure of centre when data are normally distributed\nmedian: a measure of centre, whatever the distribution\nrange: the minimum and maximum values\nmin: minimum\nmax: maximum\nIQR: interquartile range, gives the range of the middle 50% of the sample\nsd: standard deviation, a measure of the spread when data are normally distributed\nsum\nn: the number of rows the summary is calculated from\n\nFor example, if we want to generate summaries of the gross household income using the entire dataset:\n\nsummarise(ehs_tidy,\n          total_income = sum(gross_income),\n          median_income = median(gross_income),\n          n_rows = n())\n\n# A tibble: 1 × 3\n  total_income median_income n_rows\n         &lt;dbl&gt;         &lt;dbl&gt;  &lt;int&gt;\n1   397744132.        34016.   9752\n\n\nThe summarise function can be used to produce grouped summaries. This is done by first grouping the data with the group_by function.\n\n\n\n\n\n\nWarning\n\n\n\nWhenever using group_by, make sure to ungroup the data before proceeding. The grouping structure can be large and slow analysis, or may interact with other functions to produce unexpected results.\n\n\nFor example, we can expand the gross income summary table to show these summaries separated by region:\n\nehs_tidy %&gt;% \n  group_by(region) %&gt;% \n  summarise(total_income = sum(gross_income),\n            median_income = median(gross_income),\n            n_rows = n()) %&gt;% \n  ungroup()\n\n# A tibble: 9 × 4\n  region                   total_income median_income n_rows\n  &lt;fct&gt;                           &lt;dbl&gt;         &lt;dbl&gt;  &lt;int&gt;\n1 East                        55188890.        37225    1275\n2 East Midlands               31706518.        32453     806\n3 London                      59369895.        42278.   1199\n4 North East                  15381138.        26324.    474\n5 North West                  51011810.        29642    1410\n6 South East                  72646076.        39087.   1600\n7 South West                  44236539.        34958.   1105\n8 West Midlands               32522051.        30984.    878\n9 Yorkshire and the Humber    35681216.        29900    1005\n\n\nBefore creating summary tables, it is important to consider the most appropriate choice of summary statistics for your data.\n\n5.2.1 Summarising weighted data\nThe English Housing Survey is weighted to take account of the over-sampling of the less prevalent tenure groups and differential non-response, in order to provide unbiased national estimates. To account for this weighting (given by the weighting variable), we can use summary functions such as wtd.mean and wtd.quantile from the Hmisc R package:\n\nlibrary(Hmisc)\n\nsummarise(ehs_tidy,\n          mean_income_unwtd = mean(gross_income),\n          mean_income_wtd = wtd.mean(gross_income, weights = weighting),\n          median_income_unwtd = median(gross_income),\n          median_income_wtd = wtd.quantile(gross_income, \n                                           weights = weighting,\n                                           probs = .5))\n\n# A tibble: 1 × 4\n  mean_income_unwtd mean_income_wtd median_income_unwtd median_income_wtd\n              &lt;dbl&gt;           &lt;dbl&gt;               &lt;dbl&gt;             &lt;dbl&gt;\n1            40786.          41868.              34016.            35368.\n\n\nThe weighted total income is calculated by summing the product of each household income and its weight. As this variable does not currently exist within the dataset, we would need to create this first before summarising the sample:\n\nlibrary(Hmisc)\n\nehs_tidy %&gt;% \n  mutate(wtd_income = gross_income * weighting) %&gt;% \n  summarise(mean_income_unwtd = mean(gross_income),\n            mean_income_wtd = wtd.mean(gross_income, weights = weighting),\n            median_income_unwtd = median(gross_income),\n            median_income_wtd = wtd.quantile(gross_income, \n                                             weights = weighting,\n                                             probs = .5),\n            total_income_unwtd = sum(gross_income),\n            total_income_wtd = sum(wtd_income))\n\n# A tibble: 1 × 6\n  mean_income_unwtd mean_income_wtd median_income_unwtd median_income_wtd\n              &lt;dbl&gt;           &lt;dbl&gt;               &lt;dbl&gt;             &lt;dbl&gt;\n1            40786.          41868.              34016.            35368.\n# ℹ 2 more variables: total_income_unwtd &lt;dbl&gt;, total_income_wtd &lt;dbl&gt;\n\n\n\n\n5.2.2 Summarising categorical data\nTo summarise a single categorical variable, we simply need to quantify the distribution of observations lying in each group. The simplest way to do this is to count the number of observations that lie in each group. However, a simple count can be difficult to interpret without proper context. Often, we wish to present these counts relative to the total sample that they are taken from.\nThe proportion of observations in a given group is estimated as the number in the group divided by the total sample size. This gives a value between 0 and 1. Multiplying the proportion by 100 will give the percentage in each group, taking the value between 0 and 100%.\nFor example, to calculate the proportion of respondents that live in privately rented properties, we divide the total number in that group by the total number of respondents:\n\nehs_tidy %&gt;% \n1  group_by(tenure_type) %&gt;%\n2  summarise(n_tenancy = n()) %&gt;%\n3  ungroup() %&gt;%\n4  mutate(n_responses = sum(n_tenancy),\n         prop_tenure = n_tenancy / n_responses)\n\n\n1\n\nFirst group the data by tenure type\n\n2\n\nThen count the number of rows in each of these group (types)\n\n3\n\nBe sure to ungroup to remove this structure!\n\n4\n\nNow calculate the total number of respondents overall and divide the group total by the overall total\n\n\n\n\n# A tibble: 4 × 4\n  tenure_type         n_tenancy n_responses prop_tenure\n  &lt;fct&gt;                   &lt;int&gt;       &lt;int&gt;       &lt;dbl&gt;\n1 housing association      1429        9752      0.147 \n2 local authority           971        9752      0.0996\n3 owner occupied           5617        9752      0.576 \n4 private rented           1735        9752      0.178 \n\n\nFrom this summary table, the proportion of responders that lived in privately rented properties was 0.178. To convert this into a percentage, we multiple the proportions by 100%:\n\nehs_tidy %&gt;% \n  group_by(tenure_type) %&gt;% \n  summarise(n_tenancy = n()) %&gt;% \n  ungroup() %&gt;% \n  mutate(n_responses = sum(n_tenancy),\n         prop_tenure = n_tenancy / n_responses,\n         perc_tenure = prop_tenure * 100)\n\n# A tibble: 4 × 5\n  tenure_type         n_tenancy n_responses prop_tenure perc_tenure\n  &lt;fct&gt;                   &lt;int&gt;       &lt;int&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n1 housing association      1429        9752      0.147        14.7 \n2 local authority           971        9752      0.0996        9.96\n3 owner occupied           5617        9752      0.576        57.6 \n4 private rented           1735        9752      0.178        17.8 \n\n\nTherefore, 17.8% of responders lived in privately rented properties.\n\n\n5.2.3 Summarising numeric variables\nNumeric variables are typically summarised using the centre of the variable, also known as the average, and a measure of the spread of the variable. The most appropriate choice of summary statistics will depend on the distribution of the variable. More specifically, whether the numeric variable is normally distributed or not. The shape/distribution of a variable is typically investigated by plotting data in a histogram.\n\nMeasures of centre\nThe average of a numeric variable is another way of saying the centre of its distribution. Often, people will think of the mean when trying to calculate an average, however this may not always be the case.\n\n\n\n\n\n\n\n\n\nWhen data are normally distributed, the mean is the central peak of the distribution. This is calculated by adding together all numbers in the sample and dividing it by the sample size.\nHowever, when the sample is not normally distributed and the peak does not lie in the middle, extreme values or a longer tail will pull the mean towards it. Where data are not normally distributed, the mean will not be the centre and the value will be invalid. When this is the case, the median should be used instead. The median is calculated by ordering the numeric values from smallest to largest and selecting the middle value.\nWhen data are normally distributed, the mean and median will give the same, or very similar, values. This is because both are measuring the centre. However, when the data are skewed, the mean and median will differ. We prefer to use the mean where possible as it is the more powerful measure. This means that it uses more of the data than the median and is therefore more sensitive to changes in the sample.\n\n\nMeasures of spread\nGenerally the measure of the spread of a numeric variable is presented with a measure of spread, or how wide/narrow the distribution is. As with the apread, the most appropriate values will depend on whether the sample is normally distributed or not.\nThe most simple measure of spread is the range of a sample. In R, this is given as two values: the minimum and the maximum.\nThe issue with using the range is that it is entirely defined by the most extreme values in the sample and does not give any information about the rest of it. An alternative to this would be to give the range of the middle 50%, also known as the interquartile range (IQR).\nThe IQR is the difference between the 75th percentile, or upper quartile, and the 25th percentile, or lower quartile. As with the median, this is calculated by ordering the sample from smallest to largest. The sample is then cut into 4 and the quartiles are calculated. In R, the IQR is given as the difference between the upper and lower quartiles. To calculate these values separately, we can use the quantile function.\nBoth the range and IQR only use 2 values from the sample. As with the median, these measures discard a lot of information from the summaries. Where the sample is normally distributed, the standard deviation (SD) can be used which measures the average distance between each observation and the mean. The larger the SD, the wider and flatter the normal curve will be; the smaller the SD, the narrower and taller the curve will be:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe standard deviation is only appropriate where a numeric variable has a normal distribution, otherwise this value is meaningless.\n\n\nProperties of the normal distribution\nIf a sample is normally distributed, then it can be completely described using the mean and standard deviation, even when the sample values are not given. As the distribution is symmetrical, the mean and standard deviation can be used to estimate ranges of values.\nFor example, it is known that approximately 68% of a sample will lie one standard deviation from the mean, approximately 95% within 2 standard deviations from the mean, and around 99.7% within 3 standard deviations:\n\n\n\n\n\n\n\n\n\nThis knowledge can also be used to check the mean and standard deviation were appropriate summary statistics, even if we have no other information.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Combining and summarising datasets</span>"
    ]
  },
  {
    "objectID": "05_combining_summarising.html#exercise-4",
    "href": "05_combining_summarising.html#exercise-4",
    "title": "5  Combining and summarising datasets",
    "section": "Exercise 4",
    "text": "Exercise 4\n\nHow many respondents had both weekly rent and mortgage payments given? What are the potential reasons for this?\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nfilter the data to return a subgroup of respondents with both weekly rent and mortgage payments, then count the number of rows in this subgroup.\n\n\n\n\nCombine the weekly rent and mortgage variables into a single weekly payment variable.\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nThis exercise requires a new variable to be created that contains the sum of weekly rent and mortgage payments if both are observed, else it will take the observed value if just one is observed, or will remain missing if both are missing.\nYou will need a function that creates variables based on if and else conditions, and one that will take the first non-NA value. Both of these can be found in the dplyr cheatsheet or as useful functions listed in the mutate help file.\n\n\n\n\nCreate a summary table containing the mean, median, standard deviation, and the upper and lower quartiles of the weekly payment (rent and mortgage combined) for each region. What, if anything, can you infer about the distribution of this variable based on the table?\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nRemember to estimate weighted summary statistics when dealing with the EHS data. Although there is not a weighted standard deviation function in the Hmisc package, consider that standard deviation is the square root of the variance.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Combining and summarising datasets</span>"
    ]
  },
  {
    "objectID": "06_excel_data.html",
    "href": "06_excel_data.html",
    "title": "6  Loading and tidying Excel data",
    "section": "",
    "text": "6.1 Loading an Excel sheet into R\nAs with any file format, we must ensure data are in the correct form before loading them into R, ensuring each column represents a variable, each row represents an observation, and there are no tables or graphics.\nExcel files can be a little trickier to manipulate than SPSS and CSV files as they often contain multiple sheets. This is the case for the data that we will be using for this part of the course.\nThe Excel file that we will be loading contains the Office for Budget Responsibility (OBR) economic and fiscal outlook. This contains many sheets of data, but for this course we will just be focusing on three:\nLet’s begin with housing market data, stored in the 18th sheet, labelled “1.17”. This sheet can be selected in the read_xlsx function using the sheet argument.\nThe housing market sheet shows information over different time scales: first by quarters, then years, and then across pairs of years. For this example, we will extract information measured quarterly (rows 4 - 88). The argument range allows us to define the range of cells (by columns and rows) to extract.\nFinally, we can see that the column headers are not in an appropriate format for R: they contain spaces, brackets, and are very long! There are two approaches we will consider to overcome this.\nThe first is to remove the column names completely (by not including them in the range argument and setting col_names = FALSE within the read_xlsx function) and add them manually, using the setNames function.\nSetting names manually can take a long time and a lot of typing if there are many variables. An alternative to this manual approach is to include them in the range of the read_xlsx function, and use an R function to ‘clean’ them, making them follow the style guide.\nThe following code loads the housing market sheet and manually sets the variable names:\n1list.files(path = \"data\")\n\nhousing_market &lt;- \n  read_xlsx(\"data/Detailed_forecast_tables_Economy_March_2024.xlsx\",\n2                            sheet = \"1.17\",range = \"B4:J88\",\n3                            col_names = FALSE) %&gt;%\n4  setNames(c(\"period\", \"hpi_comp15\", \"hpi_prev_year\",\n             \"residential_property_transactions\", \n             \"private_enterprise_housing_starts\",\n             \"private_enterprise_housing_comp\", \n             \"housing_stock\", \"net_additions_housing_stock\",\n             \"turnover_rate\"))\n\n\n1\n\nReturn file names from the data folder\n\n2\n\nSpecify the sheet and range of cells to keep\n\n3\n\nRemove column names (too messy)\n\n4\n\nAdd variable names manually\n\n\n\n\n[1] \"Detailed_forecast_tables_Economy_March_2024.xlsx\"\n[2] \"generalfs21_EUL.sav\"                             \n[3] \"interviewfs21_EUL.sav\"\nThe following code loads the same data but uses the janitor package.\nhousing_market_alt &lt;-\n  read_xlsx(\"data/Detailed_forecast_tables_Economy_March_2024.xlsx\",\n                                # Specify the sheet and range of cells to keep\n                                sheet = \"1.17\",range = \"B3:J88\") %&gt;% \n  clean_names()",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loading and tidying Excel data</span>"
    ]
  },
  {
    "objectID": "06_excel_data.html#loading-an-excel-sheet-into-r",
    "href": "06_excel_data.html#loading-an-excel-sheet-into-r",
    "title": "6  Loading and tidying Excel data",
    "section": "",
    "text": "1.13 Household disposable income\n1.14 National living wage\n1.17 Housing market\n\n\n\n\n\n\n\n\n\n\n\nStyle tip\n\n\nThe janitor package has been designed to format inputed data to ensure it follows the Tidyverse style guide. The clean_names function can be applied to a data frame or tibble to adapt variable names in this way.\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDo not run this code without installing and loading the janitor package first. We will not run this during the course, but it is included for future reference.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loading and tidying Excel data</span>"
    ]
  },
  {
    "objectID": "06_excel_data.html#splitting-variables",
    "href": "06_excel_data.html#splitting-variables",
    "title": "6  Loading and tidying Excel data",
    "section": "6.2 Splitting variables",
    "text": "6.2 Splitting variables\nIn the current dataset, the time variable is given as a character and so is not recognised as ordered or temporal by R. To overcome this, we can split the variable to create separate year and quarter variables.\nThe str_sub function from tidyverse’s stringr package extracts elements based on their position in a string of characters. This can be used to return the first 4 digits to a new year variable, and the final digit to a new quarter variable:\n\nhousing_market &lt;- housing_market %&gt;%\n1  mutate(year =  as.numeric(str_sub(period, start = 1, end = 4)),\n         quarter = as.numeric(str_sub(period, \n2                              start = -1L, end = -1L))) %&gt;%\n3  select(-period)\n\n\n1\n\nDon’t forget to convert the string to numberic\n\n2\n\nUse - to work from the end of the string\n\n3\n\nRemove the original period variable",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loading and tidying Excel data</span>"
    ]
  },
  {
    "objectID": "06_excel_data.html#exercise-5",
    "href": "06_excel_data.html#exercise-5",
    "title": "6  Loading and tidying Excel data",
    "section": "Exercise 5",
    "text": "Exercise 5\n\nLoad in the OBR’s household disposable income data (sheet 1.13). Split the period data into separate year and quarter variables, ensure that all variable names follow Tidyverse’s style guide. Name this object disposable_income.\nLoad the OBR’s national living wage data (sheet 1.14), keep as an object named living_wage.\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nThe original variables take the name of the year they represent. However, variable names cannot begin with a number. Therefore, we must add a prefix to the original names. One way to add a prefix to a string is through the paste0 function which combines arguments in the function separated by commas into a single string. For example,\n\npaste0(\"abc\", 1, 10, \"_2010\")\n\n[1] \"abc110_2010\"\n\n\nAlthough the rename function requires each individual variable to be listed, look at the dplyr cheatsheet to find an alternative that renames variables using a function.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loading and tidying Excel data</span>"
    ]
  },
  {
    "objectID": "06_excel_data.html#transforming-data",
    "href": "06_excel_data.html#transforming-data",
    "title": "6  Loading and tidying Excel data",
    "section": "6.3 Transforming data",
    "text": "6.3 Transforming data\nThe disposable income and housing market data are currently considered in what is known as long format, with many rows and fewer variables. The alternative to this format, wide format, can be seen in the living wage data, which has many variables and few (only one!) row. Sometimes we may wish to convert between these variables, either to join them to other datasets (as is the case here), or to carry out an analysis or visualisation that requires a certain format. These conversions are carried out using the pivot_longer or pivot_wider functions.\nThere are many ways to pivot data within R (see the helpfile ?pivot_longer for a full list of arguments), and the setup of this function tends to differ for every situation. For worked examples and a more detailed explanation of the function’s capabilities, enter vignette(\"pivot\") into the console.\nFor our data, we will need to convert the wide-format living wage data to a long-format so we are able to join it to the other data. This will create a new dataset with 2 variables: year and living_wage, with a row per year. The year variable will be taken from the wide data names, and the living_wage variable will come from the wide data values:\n\nliving_wage_long &lt;- living_wage %&gt;% \n1  pivot_longer(cols = everything(),\n2               names_to = \"year\",\n3               names_prefix = \"year_\",\n4               names_transform = as.numeric,\n5               values_to = \"living_wage\")\n\n\n1\n\nFirst, select the columns that we wish to pivot (all of them). See the ?tidyr_tidy_select help file for a list of options.\n\n2\n\nMove the old variable names to a new year variable.\n\n3\n\nRemove the prefix from the old variable names.\n\n4\n\nConvert the new year variable to numeric.\n\n5\n\nTake the old cell values and create a new living_wage variable.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loading and tidying Excel data</span>"
    ]
  },
  {
    "objectID": "06_excel_data.html#exercise-6",
    "href": "06_excel_data.html#exercise-6",
    "title": "6  Loading and tidying Excel data",
    "section": "Exercise 6",
    "text": "Exercise 6\n\nCombine all three OBR datasets (housing market, disposable income and living wage) together to create one complete dataset, obr_data.",
    "crumbs": [
      "Tidyverse and data wrangling",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Loading and tidying Excel data</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html",
    "href": "07_visualisation.html",
    "title": "7  Data visualisation",
    "section": "",
    "text": "7.1 Choosing the most appropriate visualisation\nThe most appropriate choice of visualisation depends first and foremost on the goal, the context, and the audience of the visualisation. This choice will also be influenced (or restricted) by the type of variable(s) we wish to display and the number of variables. Common plots used to display combinations of different types of data are given in following table:\nTable 7.1: Common data visualisations, classified by type and number of variables, presented with the geom function used to generate them.\n\n\n\n\n\n\n\n\n\n\n\n\nNumber of variables\nType of variables\nName of visualisation\nR function\n\n\n\n\nOne variable\nCategorical\nFrequency table\ntable\n\n\n\n\nBar chart\ngeom_bar\n\n\n\nNumerical\nHistogram\ngeom_histogram\n\n\n\nSpatial\nMap\ngeom_sf\n\n\n\nTemporal\nLine plot\ngeom_line\n\n\nTwo variables\nTwo categorical\nFrequency table\ntable\n\n\n\n\nStacked/side-by-side bar chart\ngeom_bar\n\n\n\nOne numeric, one categorical\nDot plot\ngeom_point\n\n\n\n\nBox plot\ngeom_boxplot\n\n\n\nTwo numerical\nScatterplot\ngeom_point\n\n\n&gt; 2 variables\n&gt; 2 categorical\nTable\ntable\n\n\n\n2 numeric, one categorical, or &gt; 2 numeric\nScatterplot with different colours/symbols/sizes\ngeom_point\nFor a more comprehensive list (including some non-standard graphs), visit the From data to viz website.\nR is very flexible when it comes to visualising data and contains a wide variety of options to customise graphs. This section will focus on the tidyverse package ggplot2 and introduce some of the more commonly used graphical functions and parameters.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#the-ggplot2-package",
    "href": "07_visualisation.html#the-ggplot2-package",
    "title": "7  Data visualisation",
    "section": "7.2 The ggplot2 package",
    "text": "7.2 The ggplot2 package\nTThe ggplot2 package implements a ‘grammar of graphics’ approach, in which graphs are composed of multiple layers. According to the grammar of graphics, all visualisations must contain three elements: the data, the information we wish to display, and some mapping, describing how to visualise the information.\nTo illustrate this, we can create a relatively simple visualisation which investigates the distribution of tenure types in the responses of the English Housing Survey (EHS). The most appropriate visualisation for this data would be a bar chart, where each bar represents the number of responses in each tenure type.\nThe first element required for a ggplot is the data. As the other two layers are missing, this will just produce a blank plot area:\n\nggplot(data = ehs_tidy)\n\n\n\n\n\n\n\n\nThe second element that is required for a ggplot is the information we wish to present. In this case, we want to show the tenure_type variable:\n\nggplot(data = ehs_tidy,\n       aes(x = tenure_type))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAny aspect of the visualisation that is determined by a variable in the data must be surrounded by the aes() wrapper. For example, the x-axis of the visualisation is determined by the tenure_type variable which is given by the argument aes(x = tenure_type). This will be explained in more detail later in this chapter.\n\n\nThe third and final element required to generate a visualisation in ggplot2 is some physical markings of the data. Most visual markings within ggplot are determined by a geom object. In this case, the visual representation of the data will be given by bars:\n\nggplot(data = ehs_tidy,\n       aes(x = tenure_type)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nAlthough ggplot2 is part of the tidverse package, it uses a + symbol to add layers to visualisations rather than the pipe %&gt;% we have been using in other packages.\n\n\nThe plot may not be pretty, but it contains all three elements required by graphics. Additional layers will be introduced throughout this chapter to improve the design of this visualisation.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#exporting-visualisations",
    "href": "07_visualisation.html#exporting-visualisations",
    "title": "7  Data visualisation",
    "section": "7.3 Exporting visualisations",
    "text": "7.3 Exporting visualisations\nGraphs appear in the plot tab in the bottom-right of the RStudio interface and can be opened in a new window using the  icon. Graphs in this window can also be copied and pasted into other documents using the  icon and selecting Copy to clipboard.\nNew graphs will replace existing ones in this window but all graphs created in the current session of R can be explored using the  icons.\nGraphs can be stored as objects using the &lt;- symbol. These objects can then be saved as picture or PDF files using the ggsave function:\n\ntenure_bar &lt;- ggplot(data = ehs_tidy,\n                     aes(x = tenure_type, weight = weighting)) +\n  geom_line()\n\nggsave(tenure_bar, filename = \"tenure_bar.png\")\n\nThe ggsave function can be customised to change the file type, height, width and resolution (using the dpi argument).\n\n\n\n\n\n\nHint\n\n\n\nggsave is compatible with a range of file types, including png, jpg, pdf and svg. Saving these visualisations in a vectorised format, such as svg allows graph elements to be edited outside of R. For example, after pasting an exported svg file into Microsoft Word, ungroup the image. This allows customisation of axes text, legends, background colours, etc.\nExternal editing is not recommended as output would no longer be reproducible via R.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#exercise-7",
    "href": "07_visualisation.html#exercise-7",
    "title": "7  Data visualisation",
    "section": "Exercise 7",
    "text": "Exercise 7\n\nChoose an appropriate visualisation to investigate the change in household disposable income between 2012 and 2024. Comment on your findings.\n\n\n\n\n\n\n\nCaution\n\n\n\n\n\nThis exercise requires a visualisation that is appropriate for temporal numeric data. For inspiration, check Table 7.1.\nThis visualisation will require a continuous time variable on the x-axis that incorporates both the year and the quarter. If this does not currently exist, create it using the mutate function.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#aesthetic-values",
    "href": "07_visualisation.html#aesthetic-values",
    "title": "7  Data visualisation",
    "section": "7.4 Aesthetic values",
    "text": "7.4 Aesthetic values\nAny information that we are presenting that is taken from the data must be given within the aes wrapper. The argument each variable takes within this wrapper depends on the element of the graph which it defines. Additional variables can be added to a visualisation by using them to customise other elements of a graph, such as:\n\ncolour: determines the colour of points (for dot and scatterplots), lines (for line graphs), or borders (for bar charts, histograms and pie charts)\nfill: determines the colour of bars or segments\nshape: changes the symbols presented on dot and scatterplots\nlinetype: customises the type of line displayed (solid by default, but can be used to show dashed lines, etc)\nsize: determines the size of points\nlinewidth: changes the line width\nalpha: controls the transparency of graph elements\n\nThese options can be set manually or used to add variables to a visualisation. For example, the distribution of tenure types could be compared between regions by changing the fill of these bars, converting the bar chart into a stacked bar chart. When these options are determined by a variable in the data, they should be added inside the aes wrapper. Options can also be adjusted manually when the arguments are added outside of the aes wrapper.\nTo convert the previous bar chart into a stacked bar chart, we define fill by the region variable. To make these distinctions easier to see, we can also add a black outline to the bars by manually setting colour:\n\nggplot(data = ehs_tidy) + \n1  geom_bar(aes(x = tenure_type, fill = region),\n2           colour = \"black\")\n\n\n1\n\nDefine the x axis and fill inside aes\n\n2\n\nManually define colour outside aes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAesthetic markings from the data specified in the ggplot function are applied to each geom in the visualisation. These aesthetics can also be specified in each geom separately.\nWhere aesthetics are consistent over multiple geom layers, it is better to specify them in the ggplot function to avoid repetitive coding.\n\n\nEach geom has different arguments that can be customised to adapt visualisations. For example, geom_bar has the position argument which controls how additional groups are displayed. By default, this argument is set to \"stack\" which created a stacked bar chart as we saw in the last example. An alternative would be to set this to position = \"dodge\" which creates a side-by-side bar chart. Here, the tenure type bars are separated into smaller bars per region, but are displayed next to one another, rather than on top of each other:\n\nggplot(data = ehs_tidy) + \n  # Define the x axis and fill inside aes\n  geom_bar(aes(x = tenure_type, fill = region),\n           # Manually define colour outside aes\n           colour = \"black\",\n           # Show bars side-by-side instead of stacked\n           position = \"dodge\")\n\n\n\n\n\n\n\n\nFor a more comprehensive list of the options available for the geom you are interested in, check the help file (e.g. ?geom_bar).\n\n\n\n\n\n\nWarning\n\n\n\nAlthough it may be tempting to add many variables to the same visualisation, be sure that you are not overcomplicating the graph and losing important messages. It is better to have multiple clear (but simpler) visualisations than fewer confusing ones.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#exercise-8",
    "href": "07_visualisation.html#exercise-8",
    "title": "7  Data visualisation",
    "section": "Exercise 8",
    "text": "Exercise 8\n\nDisposable income is the sum of labour income, non-labour income, and net taxes and benefits. Decompose the time series created in Exercise 7 to show how the contribution of these elements to total disposable income varied across time.\n\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nConsider visualising this data as a stacked area chart rather than a line graph. The time variable will remain on the x-axis, the y-axis will be the total income, but the fill will be determined by the source of this income (labour, non-labour, or taxes and benefits). If this fill variable does not currently exist in the current wide format, consider how this could be pivoted to convert it into an alternative, more appropriate format.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#scale-functions",
    "href": "07_visualisation.html#scale-functions",
    "title": "7  Data visualisation",
    "section": "7.5 Scale functions",
    "text": "7.5 Scale functions\nScale functions allow us to customise aesthetics defined in geom objects, such as colours and axes labels. They take the form scale_'aesthetic to customise'_'scale of variable’.\n\n7.5.1 Customising axes\nScale functions can be used to customise axis titles, limits, breaks, and labels. The choice of scale function is determined by the type of variable displayed on the axis.\nFor example, if we wanted to investigate the distribution of gross incomes in the EHS data, we could generate a weighted histogram. The geom required for this visualisation would be geom_histogram, which also contains an optional aes argument weights:\n\n\n\n\n\n\nWarning\n\n\n\nRemember that the value 100000 is actually a grouped variable containing all household with a gross income of £100,000 or over.\n\n\n\nggplot(data = ehs_tidy) +\n  geom_histogram(aes(x = gross_income, weight = weighting))\n\n\n\n\n\n\n\n\nWe could improve the appearance of this histogram by changing the axis label, the colour scheme of the bars, and could remove the blank space between the graph area and the axes. As the gross income is a numberic variable, we could use the scale_x_continuous function to customise its appearance. Arguments to customise the x or y axes include:\n\nname = to change the axis title\nlimits = c(...) sets the axis limits\nbreaks = c(...) defines tick marks\nlabels = c(...) attaches labels to break values. This can be combined with a function from the scales package (which is automatically loaded with ggplot2) to apply common formats to labels (see the package reference website for examples).\nexpand = expansion(0) removes the default blank space around the axis limits (this can also be used to add space by replacing 0 with either add = or mult = depending if this change is additive or multiplicative)\ntransform = transform the scale the axis is shown on. Transformations include reverse, sqrt, log, etc. For a full list, view the appropriate help file\n\n\nggplot(data = ehs_tidy) +\n  geom_histogram(aes(x = gross_income, weight = weighting),\n1                 colour = \"black\", fill = \"thistle\") +\n2  scale_x_continuous(name = \"Gross income (£)\",\n3                     expand = expansion(add = 750),\n4                     labels = scales::label_comma()) +\n  scale_y_continuous(name = \"Total households\", \n                     expand = expansion(mult = .01), \n5                     breaks = seq(0, 1750000, by = 250000),\n                     labels = scales::label_comma())\n\n\n1\n\nManually change the outline and fill of bars to improve the appearance\n\n2\n\nChange the axis title to remove underscore, add capitalisation, and add scale\n\n3\n\nControl the blank space between the axis and bars (add 750 to either side)\n\n4\n\nFormat axis labels to have a comma every 3 digits (e.g. convert 100000 to 100,000) to improve readability\n\n5\n\nAdd axis breaks every 250,000 households (look up the ?seq help file to learn more about how this can be customised)\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.5.2 Customising colour scales\nThere is a wide range of options available for customising colour and fill aesthetics within ggplot2. The choice will depend on the type of variable determining colours (whether it is numeric or categorical) and whether we want to use a pre-defined colour palette or manually specify our own.\n\n\n\n\n\n\nWarning\n\n\n\nWhen choosing a colour palette, be sure that all colours are distinct to everyone, including those with colour-vision deficiencies. To help check this is the case, use a colour blindness simulator to see what a visualisation looks like under different types of colour blindness.\nAvoid potentially harmful stereotypes when choosing colours to represent groups, and avoid cyclical palettes, such as the rainbow palette, to avoid confusion between high and low values.\n\n\n\n\n7.5.2.1 Pre-built colour palettes\nThere are thousands of colour palettes that are available within R. Some of them are included within the ggplot2 package, but there are many others that require additional package installation. This website gives a list and preview of all palettes currently available.\nColour palettes included within the ggplot2 package (and therefore don’t require any additional packages) are the viridis and colorbrewer scales. Both contain palettes that are colourblind friendly and can be used for either continuous or discrete scales.\nFor continuous data, use scale_colour_viridis_c or scale_colour_distiller to select one of the in-built colour palettes (replace colour with fill when dealing with bars). For discrete or categorical variables, use scale_colour_viridis_d or scale_colour_brewer instead.\n\n\n7.5.2.2 Manually defining a colour palette\nThere are various way of creating your own colour palette if you (or the department you are part of) have preferred colours.\nFor discrete or categorical variables, the scale_colour_manual (or scale_fill_manual) function allows colours to be specified using the values argument.\n\n\n\n\n\nStyle tip\n\n\nR contains a list of 657 pre-programmed colours that can be used to create palettes (run colours() in the console for a full list).\nHexadecimal codes can also be included instead in the form #rrggbb (where rr (red), gg (green), and bb (blue) are numbers between 00 and 99 giving the level of intensity of each colour).\n\n\n\n\n\n\n\n\nHint\n\n\n\nWhere a colour palette will be used across multiple plots, defining this list of colours as a vector and then entering this into scale_fill_manual will reduce repetitive coding.\n\n\n\nregion_palette &lt;- c(\"aquamarine2\", \"blue\", \"chartreuse2\", \"coral\", \"orchid\",\n                    \"firebrick\", \"gold3\", \"violetred\", \"grey50\")\n\nggplot(data = ehs_tidy) + \n  geom_bar(aes(x = tenure_type, fill = region),\n           colour = \"black\",\n           position = \"dodge\") +\n  scale_fill_manual(name = \"Region\", values = region_palette)\n\n\n\n\n\n\n\n\nWhen including a continuous variable, palettes can be created using gradients. The choice of function depends on the number of gradients required:\n\nscale_colour_gradient / scale_fill_gradient: specifies a two colour gradient based on a low and high value\nscale_colour_gradient2 / scale_fill_gradient2: specifies a three colour gradient based on a low, mid (defined by the midpoint argument), and high value\nscale_colour_gradientn / scale_fill_gradientn: specifies a palette with more than three colours, customised by setting colours and corresponding values.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#annotations-and-titles",
    "href": "07_visualisation.html#annotations-and-titles",
    "title": "7  Data visualisation",
    "section": "7.6 Annotations and titles",
    "text": "7.6 Annotations and titles\nBesides the layers required to generate a visualisation, additional layers can be added enhance the messages given by the data, drawing readers’ attention to interesting findings and the story you are trying to tell.\n\n7.6.1 Plot, axes and legend titles\nAlthough axis and legend labels can be updated within scale functions, the labs function exist as an alternative. This function also allows us to add titles, subtitles and footnotes to visualisations:\n\nggplot(data = ehs_tidy) + \n  geom_bar(aes(x = tenure_type, fill = region),\n           colour = \"black\") +\n  scale_fill_manual(values = region_palette) +\n  labs(title = \"This is a title\", \n       subtitle = \"Here is a subtitle\",\n       x = \"Tenure type\", y = \"Number of households\",\n       fill = \"Region\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyle tip\n\n\n\\n can be used to specify line breaks within the labs arguments.\nSpecifying any of the arguments in labs as NULL (no speech marks) removes the title from the visualisation.\nMathematical equations can be added into labs arguments by surrounding the text with the quote() function. Check ?plotmath for examples of equation syntax.\n\n\n\n\n7.6.2 Annotations\nAnnotations can be useful to include context to visualisations and draw attention to important messages. Annotations can include text labels, reference lines and shading, amongst others. ggplot2 contains a number of geom objects that can be used to add annotation layers to a visualisation. As these annotations are added within geoms, they can be specified using values from the data (when wrapped in the aes function) or manually. This section will cover some common annotations but there are many others available (see the ggplot ebook for a more comprehensive list).\n\n7.6.2.1 Text labels\nText labels can either be added using geom_text or geom_label (which adds text surrounded by a rectangular box, making it easier to read on busy backgrounds). Aesthetics such as x, y and colour can be used to customise text labels (either manually or from the data). Other aesthetics that can be added include:\n\nlabel defines the text displayed\nangle rotates the text\nfamily defines the font\nfontface can be changed to make text \"bold\" or \"italic\"\n\n\nggplot(data = ehs_tidy) +\n  geom_histogram(aes(x = gross_income, weight = weighting),\n                 colour = \"black\", fill = \"thistle\") + \n  scale_x_continuous(name = \"Gross income (£)\", \n                     expand = expansion(add = 750), \n                     labels = scales::label_comma()) + \n  scale_y_continuous(name = \"Total households\", \n                     expand = expansion(mult = .01), \n                     breaks = seq(0, 1750000, by = 250000), \n                     labels = scales::label_comma()) +\n  geom_text(x = 75000, y = 1250000, \n            label = \"Gross income \\n over £100,000\") +\n  geom_label(x = 50000, y = 1500000, label = \"Italicised label\",\n             fontface = \"italic\")\n\n\n\n\n\n\n\n\nAdding text through geoms will work but notice that the annotations looks a little blurry on the text. This is because geom layers take the data into account and assume that you want the same number of layers/markings as observations in the data. This means that rather than adding a single text or label, ggplot is actually adding 9752. To overcome this, we can use the annotate function instead.\n\n\n\n7.6.3 Annotate function\nThe annotate function will add single geom layers to a visualisation while disregarding the rest of the data. This is useful when adding annotations such as text, labels, shapes or arrows. annotate functions require the same arguments as the corresponding geom, with an additional argument that specifies the geom we require.\nFor example, the blurry labels on our previous plot can be fixed by replacing geom_text and geom_label with annotate functions:\n\nggplot(data = ehs_tidy) +\n  geom_histogram(aes(x = gross_income, weight = weighting),\n                 colour = \"black\", fill = \"thistle\") + \n  scale_x_continuous(name = \"Gross income (£)\", \n                     expand = expansion(add = 750), \n                     labels = scales::label_comma()) + \n  scale_y_continuous(name = \"Total households\", \n                     expand = expansion(mult = .01), \n                     breaks = seq(0, 1750000, by = 250000), \n                     labels = scales::label_comma()) +\n  annotate(\"text\", x = 75000, y = 1250000, \n           label = \"Gross income \\n over £100,000\") +\n  annotate(\"label\", x = 50000, y = 1500000, label = \"Italicised label\",\n            fontface = \"italic\")\n\n\n\n\n\n\n\n\nText labels can be combined with lines and arrows to make them clearer, using the curve (for curved lines) or segment (for straight lines) geoms. Both contain the optional argument arrow which adds an arrow to the curved line (this must be defined within the arrow function, which can be used to adjust the size or shape of the arrow):\n\nggplot(data = ehs_tidy) +\n  geom_histogram(aes(x = gross_income, weight = weighting),\n                 colour = \"black\", fill = \"thistle\") + \n  scale_x_continuous(name = \"Gross income (£)\", \n                     expand = expansion(add = 750), \n                     labels = scales::label_comma()) + \n  scale_y_continuous(name = \"Total households\", \n                     expand = expansion(mult = .01), \n                     breaks = seq(0, 1750000, by = 250000), \n                     labels = scales::label_comma()) +\n  annotate(\"segment\", x = 87000, xend = 98000, y = 1250000,\n           arrow = arrow(length = unit(.25, \"cm\"))) +\n  annotate(\"text\", x = 75000, y = 1250000, \n           label = \"Gross income \\n over £100,000\") \n\n\n\n\n\n\n\n\nOther useful annotations that can enhance visualisations’ messages include:\n\nrect: draws a rectangle that can be used to highlight a section of the graph\ngeom_vline, geom_hline and geom_abline: adds a vertical, horizontal, or diagonal reference line across the entire graph area (these geoms are not compatible with the annotate function)",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#theme-functions",
    "href": "07_visualisation.html#theme-functions",
    "title": "7  Data visualisation",
    "section": "7.7 Theme functions",
    "text": "7.7 Theme functions\nThe theme function modifies non-data components of the visualisation. For example, the legend position, label fonts, graph background, and grid lines. There are many options that can be adjusted within the theme function (see the help file ?theme for a complete list). Often, it is efficient to begin with a pre-built theme and tweak elements that do not suit our purpose.\n\n7.7.1 Pre-built themes\nThere are 8 complete themes programmed in the ggplot2 package. These are:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyle tip\n\n\nAlthough pre-built theme functions do not require arguments to run, they all contain the optional argument base_size which set the default font size (defaulted to 11). To ensure visualisations are as accessible and inclusive as possible, ensure this is set to at least 12 for printed graphs or 36 for presentations.\n\n\n\n\n7.7.2 Customising themes\nIndividual elements of a visualisation’s theme can be customised within the theme functions. Many elements that can be customised using the theme require an element wrapper. This wrapper is determined by the type of object that we are customising, the four options are:\n\nelement_text when customising text, e.g. axis titles and labels\nelement_rect when customising backgrounds, e.g. the graph area\nelement_line when customising lines, e.g. gridlines\nelement_blank to remove elements\n\nElements that do not require these wrappers are often related to positioning. A common example of this is the legend.position argument which can be set to \"left\", \"right\" (default), \"top\", \"bottom\", or removed using \"none\".\nFor example, the histogram we have been building showing household gross income can be customised using theme functions:\n\nhistogram_minimal &lt;- ggplot(data = ehs_tidy) +\n  geom_histogram(aes(x = gross_income, weight = weighting),\n                 colour = \"black\", fill = \"thistle\") + \n  scale_x_continuous(name = \"Gross income (£)\", \n                     expand = expansion(add = 1000), \n                     labels = scales::label_comma()) + \n  scale_y_continuous(name = \"Total households\", \n                     expand = expansion(mult = .01), \n                     breaks = seq(0, 1750000, by = 250000), \n                     labels = scales::label_comma()) +\n  annotate(\"segment\", x = 87000, xend = 98000, y = 1300000,\n           arrow = arrow(length = unit(.25, \"cm\"))) +\n  annotate(\"label\", x = 75000, y = 1300000, \n           label = \"Gross income \\n over £100,000\") +\n  theme_minimal()\n\nhistogram_minimal\n\n\n\n\n\n\n\n\n\nhistogram_minimal +\n1  theme(axis.title = element_text(size = 14, face = \"bold\"),\n2        axis.text.x = element_text(size = 12),\n3        axis.text.y = element_text(size = 12, angle = 45),\n4        panel.grid.major = element_line(colour = \"black\"),\n5        panel.grid.minor = element_line(colour = \"grey45\",\n                                        linetype = \"dashed\"))\n\n\n1\n\nIncrease the axis title size and make them bold\n\n2\n\nSet the x-axis text size to 12\n\n3\n\nSet the y-axis text size to 12 and rotate them 45 degrees\n\n4\n\nAdd major grid lines\n\n5\n\nAdd dashed minor grid lines\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyle tip\n\n\nGood visualisations require a middle ground between overly minimal design, which can make interpretation difficult, and charts overloaded with clutter. The bold and dashed grid lines on this visualisations are a good example of where ‘chart junk’ can distract from the data.\nVisualisations should strive to make the data are the most important part of the graphic, whilst ensuring there is sufficient context provided by non-data elements.\n\n\n\n\n7.7.3 Creating a theme\nOne benefits of using theme functions is that visualisations will remain consistent in terms of their design. Custom themes can be saved as functions and added to ggplot objects in place of the in-built themes. For example,\nTo create our own function in R, we first give it a name and attach function() followed by curly brackets {}, with the function defined inside those brackets.\nFor example, to create our own theme function, called theme_dataviz, which sets the title font size to 18, the axis and legend titles to size 14, the axis and legend text to size 12, adds just gridlines to the y-axis, and changes the background colours, we use the following:\n\ntheme_dataviz &lt;- function() {\n  theme_light() +\n  theme(plot.title = element_text(size = 18),\n        axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12),\n        legend.text = element_text(size = 12),\n        legend.title = element_text(size = 14),\n        panel.grid.major.y = element_line(colour = \"grey45\"))\n}\n\nThe function theme_dataviz will now appear in the Environment window and can be added to ggplot objects:\n\nggplot(data = ehs_tidy) + \n  geom_bar(aes(x = tenure_type, fill = region),\n           colour = \"black\",\n           position = \"dodge\") +\n  scale_fill_manual(name = \"Region\", values = region_palette) +\n  scale_x_discrete(labels = scales::label_wrap(12)) +\n  labs(x = \"Tenure type\", y = \"Number of households\") +\n  theme_dataviz()\n\n\n\n\n\n\n\n\nCreating a personalised theme ensures that visualisations are consistent, whilst keeping code concise and reducing repetition.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#facet-functions",
    "href": "07_visualisation.html#facet-functions",
    "title": "7  Data visualisation",
    "section": "7.8 Facet functions",
    "text": "7.8 Facet functions\nFaceting allows us to divide a plot into subplots based on some grouping variable within the data. This allows us to show multiple variables in the same visualisation without risking overloading the plot and losing the intended message.\nFor example, we could compare the relationship between gross income and tenure type (shown using a boxplot) between regions by faceting the graph by region using the facet_wrap function:\n\n\n\n\n\n\nWarning\n\n\n\nRemember that the value 100,000 actually represents anyone earning £100,000 or more. To avoid skewing the data, we will remove these values and investigate trends below this threshold.\n\n\n\nehs_tidy %&gt;% \n1  filter(gross_income != 100000) %&gt;%\n2  ggplot() +\n  geom_boxplot(aes(x = tenure_type, y = gross_income)) +\n3  scale_x_discrete(labels = scales::label_wrap(8)) +\n  scale_y_continuous(labels = scales::label_comma()) +\n  labs(x = \"Tenure type\", y = \"Gross income (£)\") +\n  facet_wrap( ~ region) +\n  theme_dataviz()\n\n\n1\n\nRemove gross income &gt;= £100,000\n\n2\n\nWe do not need to specify data, it is already passed through the pipes\n\n3\n\nWrap tenure type labels to avoid overlap",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "07_visualisation.html#exercise-9",
    "href": "07_visualisation.html#exercise-9",
    "title": "7  Data visualisation",
    "section": "Exercise 9",
    "text": "Exercise 9\nReturn to the visualisation showing the change in disposable income over time, decomposed into different income streams (labour, non-labour, and taxes and benefits). Adapt the visualisation to ensure it is accessible, compelling, and clear. This can include:\n\nAdding an appropriate title and caption with data source information\nAdapting the colour scheme to make the differences more obvious\nAdding labels to commmunicate important findings to the reader\nAdjusting the theme to ensure text is large enough, values are clear but not overwhelmed by ‘chart junk’\n\nSave this visualisation and add it into a Word document, along with a brief interpretation of the visualisation.\n\n\n\n\n\n\nExercise hint\n\n\n\n\n\nAdd layers to the previous geom_area from exercise 8. Use the labs function to add a title and caption, and to ensure axes and legend titles are clear. Use scale_fill_manual to manually enter colours or scale_fill_brewer to choose a pre-existing palette.\nConsider adding text labels to each element of the disposable income to give the percentage split represented by each element.\nEnsure your theme sets all text and titles to size 12 or larger, adds enough grid lines to make values readable, but not so many that it distracts from the data.",
    "crumbs": [
      "Data visualisation",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Data visualisation</span>"
    ]
  },
  {
    "objectID": "exercise2_solutions.html",
    "href": "exercise2_solutions.html",
    "title": "Appendix A — Exercise 2 solutions",
    "section": "",
    "text": "A.1 Question 1\nAdd your name and the date to the top of your script file (hint: comment this out so R does not try to run it)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Exercise 2 solutions</span>"
    ]
  },
  {
    "objectID": "exercise2_solutions.html#solution",
    "href": "exercise2_solutions.html#solution",
    "title": "Appendix A — Exercise 2 solutions",
    "section": "Solution",
    "text": "Solution\n\nAdd a # at the beginning of the row, followed by your name and the date, for example:\n\n\n# Sophie 18/11/2024",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Exercise 2 solutions</span>"
    ]
  },
  {
    "objectID": "exercise2_solutions.html#question-2",
    "href": "exercise2_solutions.html#question-2",
    "title": "Appendix A — Exercise 2 solutions",
    "section": "A.2 Question 2",
    "text": "A.2 Question 2\nUse R to answer to following sums:\n\n\\(64^2\\)\n\\(3432 \\div 8\\)\n\\(96 \\times 72\\)\n\nFor each part of question 2, copy the result from the console and paste them onto the same line of the script file as the code. Do this in a way that ensures there are no error messages if you were to run the entire script file.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Exercise 2 solutions</span>"
    ]
  },
  {
    "objectID": "exercise2_solutions.html#solution-1",
    "href": "exercise2_solutions.html#solution-1",
    "title": "Appendix A — Exercise 2 solutions",
    "section": "Solution",
    "text": "Solution\nFor each calculation, copy the result from the console and paste it in the script file after a # symbol:\n\n64^2   # 4092\n\n3432 / 8  # 429\n\n96 * 72  # 6912",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Exercise 2 solutions</span>"
    ]
  },
  {
    "objectID": "exercise3_solutions.html",
    "href": "exercise3_solutions.html",
    "title": "Appendix B — Exercise 3 solutions",
    "section": "",
    "text": "B.1 Question 1\nYou have been provided with another .sav file which contains the interview responses from the EHS. Create and save a tidy version of this dataset, ensuring variables are classified as the correct type and names follow the style conventions (if you cannot remember these, check here for a reminder.\nThe variables we need in the tidy dataset are:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Exercise 3 solutions</span>"
    ]
  },
  {
    "objectID": "exercise3_solutions.html#question-1",
    "href": "exercise3_solutions.html#question-1",
    "title": "Appendix B — Exercise 3 solutions",
    "section": "",
    "text": "The unique identifier serialanon\nThe gross household income HYEARGRx\nThe length of residence lenresb\nThe weekly rent rentwkx and mortgage mortwkx payments\nWhether the property is freehold or leasehold freeLeas\n\n\nSolution\nThe first step is to load in the data. However, before this, we need the name of the file. We can look into our documents to get this, but the list.files function will do it for us:\n\nlist.files(path = \"data\")\n\n[1] \"Detailed_forecast_tables_Economy_March_2024.xlsx\"\n[2] \"generalfs21_EUL.sav\"                             \n[3] \"interviewfs21_EUL.sav\"                           \n\n\nFrom the console, we can copy and paste the file name into the read_spss function:\n\nehs_interview_tidy &lt;- read_spss(\"data/interviewfs21_EUL.sav\")\n\nNext, we can select just the variables we need to reduce the data size:\n\nehs_interview_tidy &lt;- read_spss(\"data/interviewfs21_EUL.sav\") %&gt;% \n  select(serialanon, HYEARGRx, lenresb, rentwkx, mortwkx, freeLeas)\n\nWe can now explore this data to see which variables need converting, and which are truly numeric:\n\nstr(ehs_interview_tidy)\n\ntibble [9,752 × 6] (S3: tbl_df/tbl/data.frame)\n $ serialanon: dbl+lbl [1:9752] 2.02e+10, 2.02e+10, 2.02e+10, 2.02e+10, 2.02e+10, 2.0...\n   ..@ label        : chr \"Key variable: unique archived identifier\"\n   ..@ format.spss  : chr \"F11.0\"\n   ..@ display_width: int 13\n   ..@ labels       : Named num [1:2] -9 -8\n   .. ..- attr(*, \"names\")= chr [1:2] \"Does not apply\" \"No Answer\"\n $ HYEARGRx  : dbl+lbl [1:9752]  38378,  26525,  25273,  51280,  14365,  38955,  2137...\n   ..@ label        : chr \"Household gross annual income (inc. income from all adult household members)\"\n   ..@ format.spss  : chr \"F8.2\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num 1e+05\n   .. ..- attr(*, \"names\")= chr \"£100,000 or more\"\n $ lenresb   : dbl+lbl [1:9752] 7, 8, 6, 4, 8, 8, 6, 2, 6, 8, 6, 4, 8, 5, 4, 5, 4, 3,...\n   ..@ label        : chr \"Length of residence\"\n   ..@ format.spss  : chr \"F8.0\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:10] -9 -8 1 2 3 4 5 6 7 8\n   .. ..- attr(*, \"names\")= chr [1:10] \"does not apply\" \"no answer\" \"less than 1 year\" \"one year\" ...\n $ rentwkx   : dbl+lbl [1:9752]    NA,    NA,    NA,    NA,    NA,    NA,    NA,    N...\n   ..@ label        : chr \"Total weekly rent payable (rent plus housing benefit)\"\n   ..@ format.spss  : chr \"F8.2\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num -9\n   .. ..- attr(*, \"names\")= chr \"question not applicable - owner occupier and not shared ownership\"\n $ mortwkx   : dbl+lbl [1:9752]    NA,    NA,    NA, 184.6,  88.8,    NA,    NA, 313....\n   ..@ label        : chr \"Weekly mortgage payments\"\n   ..@ format.spss  : chr \"F8.2\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:3] -9 -8 0\n   .. ..- attr(*, \"names\")= chr [1:3] \"not applicable - tenant\" \"unknown\" \"no payments - own outright\"\n $ freeLeas  : dbl+lbl [1:9752]  1,  1,  1,  1,  1,  1,  1,  1, NA,  1,  1, NA,  1, N...\n   ..@ label        : chr \"Freehold or leasehold\"\n   ..@ format.spss  : chr \"F8.0\"\n   ..@ display_width: int 10\n   ..@ labels       : Named num [1:4] -9 -8 1 2\n   .. ..- attr(*, \"names\")= chr [1:4] \"does not apply\" \"no answer\" \"freehold\" \"leasehold\"\n - attr(*, \"label\")= chr \"Aggregated File\"\n\n\nAs with the general data, all variables are classified as dbl + lbl by R. Of these, the length of residence and freehold/leashold variables appear to by categorical. There are also labels attached to the gross annual income (for those over £100,000) which we need to be aware of when analysing this data.\nTherefore, our next step will involve converting the categorical variables into factors:\n\nehs_interview_tidy &lt;- read_spss(\"data/interviewfs21_EUL.sav\") %&gt;% \n  select(serialanon, HYEARGRx, lenresb, rentwkx, mortwkx, freeLeas) %&gt;% \n  mutate(length_residence = as_factor(lenresb),\n         freehold_leasehold = as_factor(freeLeas))\n\nhead(ehs_interview_tidy)\n\n# A tibble: 6 × 8\n  serialanon  HYEARGRx  lenresb        rentwkx mortwkx freeLeas length_residence\n  &lt;dbl+lbl&gt;   &lt;dbl+lbl&gt; &lt;dbl+lbl&gt;      &lt;dbl+l&gt; &lt;dbl+l&gt; &lt;dbl+lb&gt; &lt;fct&gt;           \n1 20220000001 38378.    7 [20-29 year… NA       NA     1 [free… 20-29 years     \n2 20220000005 26525     8 [30+ years]  NA       NA     1 [free… 30+ years       \n3 20220000006 25272.    6 [10-19 year… NA       NA     1 [free… 10-19 years     \n4 20220000012 51280.    4 [3-4 years]  NA      185.    1 [free… 3-4 years       \n5 20220000013 14365     8 [30+ years]  NA       88.8   1 [free… 30+ years       \n6 20220000017 38955     8 [30+ years]  NA       NA     1 [free… 30+ years       \n# ℹ 1 more variable: freehold_leasehold &lt;fct&gt;\n\n\nFinally, we need to rename the existing variables to ensure they are informative and follow the style rules, and remove any unnecessary variables:\n\nehs_interview_tidy &lt;- read_spss(\"data/interviewfs21_EUL.sav\") %&gt;% \n  select(serialanon, HYEARGRx, lenresb, rentwkx, mortwkx, freeLeas) %&gt;% \n  mutate(length_residence = as_factor(lenresb),\n         freehold_leasehold = as_factor(freeLeas)) %&gt;% \n  rename(id = serialanon,\n         gross_income = HYEARGRx,\n         weekly_rent = rentwkx,\n         weekly_mortgage = mortwkx) %&gt;% \n  select(id, gross_income, length_residence, weekly_rent, weekly_mortgage, \n         freehold_leasehold)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Exercise 3 solutions</span>"
    ]
  },
  {
    "objectID": "exercise3_solutions.html#question-2",
    "href": "exercise3_solutions.html#question-2",
    "title": "Appendix B — Exercise 3 solutions",
    "section": "B.2 Question 2",
    "text": "B.2 Question 2\nSave the tidy interview dataset as a csv file with an appropriate file name.\n\nSolution\n\nwrite_csv(ehs_interview_tidy, file = \"saved_data/ehs_interview_tidy.csv\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Exercise 3 solutions</span>"
    ]
  },
  {
    "objectID": "exercise3_solutions.html#question-3",
    "href": "exercise3_solutions.html#question-3",
    "title": "Appendix B — Exercise 3 solutions",
    "section": "B.3 Question 3",
    "text": "B.3 Question 3\nUsing the new, tidy dataset, answer the following questions:\n\nHow many respondents paid weekly rent of between £150 and £300?\nHow many respondents did not give a response to either the weekly rent or weekly mortgage question?\nWhat is the highest household gross income of these responders?\n\n\nSolution\nFor the first two part, we use the filter function to return a subgroup matching the condition, and combine this with the count function that counts the number of rows in a tibble:\n\nehs_interview_tidy %&gt;% \n  filter(between(weekly_rent, 150, 300)) %&gt;% \n  count()\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1   993\n\nehs_interview_tidy %&gt;% \n  filter(is.na(weekly_rent), is.na(weekly_mortgage)) %&gt;% \n  count()\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1  2956\n\n\nThere were 993 respondents that paid weekly rent of between £150 and £300.\nThere were 2956 respondents that did not give a response to either the weekly rent or mortgage question.\nThe final part could usually be carried out with the base R max function:\n\nmax(ehs_interview_tidy$gross_income)\n\n&lt;labelled&lt;double&gt;[1]&gt;: Household gross annual income (inc. income from all adult household members)\n[1] 1e+05\n\nLabels:\n value            label\n 1e+05 £100,000 or more\n\n\nHowever, the labels attached to the SPSS file showed that a value of 100000 actually represents a group of responders earning at least £100,000. Therefore, we cannot answer this question from the available data. If we were to analyse this variable, we would need to categorise the rest of the data, losing a lot of information. Failure to do this would produce invalid results.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Exercise 3 solutions</span>"
    ]
  },
  {
    "objectID": "exercise4_solutions.html",
    "href": "exercise4_solutions.html",
    "title": "Appendix C — Exercise 4 solutions",
    "section": "",
    "text": "C.1 Question 1\nHow many respondents had both weekly rent and mortgage payments given? What are the potential reasons for this?",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Exercise 4 solutions</span>"
    ]
  },
  {
    "objectID": "exercise4_solutions.html#question-1",
    "href": "exercise4_solutions.html#question-1",
    "title": "Appendix C — Exercise 4 solutions",
    "section": "",
    "text": "Solution\nWe can combine the filter and count functions to answer the first part of this question:\n\nehs_tidy %&gt;% \n  filter(!is.na(weekly_rent), !is.na(weekly_mortgage)) %&gt;% \n  count()\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1   105\n\n\nThere were 105 respondents with both weekly rent and mortgage payments.\nTo understand why this is, we could first view this data (or a summary of the data) to see what other characteristics these respondents share:\n\nehs_tidy %&gt;% \n  filter(!is.na(weekly_rent), !is.na(weekly_mortgage)) %&gt;% \n  summary()\n\n       id              weighting                    tenure_type \n Min.   :2.022e+10   Min.   :  305.5   housing association:  0  \n 1st Qu.:2.022e+10   1st Qu.:  628.9   local authority    :  0  \n Median :2.022e+10   Median : 1058.4   owner occupied     :105  \n Mean   :2.022e+10   Mean   : 1859.3   private rented     :  0  \n 3rd Qu.:2.022e+10   3rd Qu.: 2535.4                            \n Max.   :2.022e+10   Max.   :10568.5                            \n                                                                \n           region    gross_income            length_residence  weekly_rent    \n South East   :22   Min.   :  9880   two years       :27      Min.   :  8.30  \n East         :19   1st Qu.: 26595   one year        :19      1st Qu.: 49.80  \n London       :19   Median : 39655   3-4 years       :15      Median : 69.69  \n North West   :13   Mean   : 41908   5-9 years       :15      Mean   : 86.23  \n South West   :13   3rd Qu.: 52323   less than 1 year: 9      3rd Qu.:120.00  \n East Midlands: 8   Max.   :100000   10-19 years     : 8      Max.   :219.23  \n (Other)      :11                    (Other)         :12                      \n weekly_mortgage    freehold_leasehold\n Min.   :  0.0231   freehold :29      \n 1st Qu.:  0.0231   leasehold:65      \n Median : 60.0000   NA's     :11      \n Mean   : 71.6271                     \n 3rd Qu.:103.8462                     \n Max.   :343.8138                     \n                                      \n\n\nAll respondents in this group owned and lived in their own home. Most were leasehold properties, suggesting some of the weekly rent refers to lease payments. Other potential reasons could include shared ownership (which is not given as an option for tenure type), or respondents that lived with renters in the same property.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Exercise 4 solutions</span>"
    ]
  },
  {
    "objectID": "exercise4_solutions.html#question-2",
    "href": "exercise4_solutions.html#question-2",
    "title": "Appendix C — Exercise 4 solutions",
    "section": "C.2 Question 2",
    "text": "C.2 Question 2\nCombine the weekly rent and mortgage variables into a single weekly payment variable.\n\nSolution\nWhere only one value has been recorded, we want to use this in the new variable. Where both have been recorded, we will need to add the values together to get a weekly total.\nThere are a few different ways to do this. The first is to include an if_else statement in the mutate function, changing how the variable is calculated whether either value is missing or not:\n\nehs_tidy_ex4 &lt;- ehs_tidy %&gt;% \n1  mutate(weekly_total = if_else(is.na(weekly_rent) |\n                                  is.na(weekly_mortgage),\n2                                coalesce(weekly_rent, weekly_mortgage),\n3                                weekly_rent + weekly_mortgage))\n\n\n1\n\nIf either weekly_rent or weekly_mortgage are missing\n\n2\n\nThen return the non-missing value\n\n3\n\nOr else (if both are NOT missing), return the sum of these values",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Exercise 4 solutions</span>"
    ]
  },
  {
    "objectID": "exercise4_solutions.html#question-3",
    "href": "exercise4_solutions.html#question-3",
    "title": "Appendix C — Exercise 4 solutions",
    "section": "C.3 Question 3",
    "text": "C.3 Question 3\nCreate a summary table containing the mean, median, standard deviation, and the upper and lower quartiles of the weekly payment (rent and mortgage combined) for each region. What, if anything, can you infer about the distribution of this variable based on the table?\n\nSolution\n\nehs_tidy_ex4 %&gt;% \n1  group_by(region) %&gt;%\n2  summarise(mean_payment = wtd.mean(weekly_total, weights = weighting,\n                                    na.rm = TRUE),\n3            median_payment = wtd.quantile(weekly_total,\n                                          weights = weighting,\n                                          probs = .5, na.rm = TRUE),\n4            sd_payment = sqrt(wtd.var(weekly_total, weights = weighting,\n                                      na.rm = TRUE)),\n5            lq_payment = wtd.quantile(weekly_total, weights = weighting,\n                                      probs = .25, na.rm = TRUE),\n6            uq_payment = quantile(weekly_total, weights = weighting,\n                                  probs = .75, na.rm = TRUE)) %&gt;%\n7  ungroup()\n\n\n1\n\nCalculate summaries per region\n\n2\n\nReturn the weighted mean\n\n3\n\nReturn the weighted median (the 50th percentile)\n\n4\n\nReturn the weighted standard deviation (the square root of the weighted variance)\n\n5\n\nReturn the weighted lower quartile (the 25th percentile)\n\n6\n\nReturn the weighted upper quartile (the 75th percentile)\n\n7\n\nDon’t forget to ungroup\n\n\n\n\n# A tibble: 9 × 6\n  region            mean_payment median_payment sd_payment lq_payment uq_payment\n  &lt;fct&gt;                    &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 East                      182.          150        154.       104.        208.\n2 East Midlands             151.          125.       117.        93         162.\n3 London                    283.          254.       223.       135         346.\n4 North East                111.           96.9       52.6       81         115.\n5 North West                124.          110.        68.7       85.2       138.\n6 South East                210.          179.       149.       121.        245.\n7 South West                153.          138.        92.0       97         183.\n8 West Midlands             142.          122.        88.1       92         150 \n9 Yorkshire and th…         120.          107.        76.4       82         133.\n\n\nThere are big differences between most mean and medians across regions, indicating that the data are not normally distributed. If we use the approximate 95% range formula (mean \\(\\pm\\) (2 \\(\\times\\) sd)), we would get negative values for almost all regions. Negative payments do not make sense in this context, confirming that the data are not normally distributed.\nIn this case, the median and IQR should be give, not the mean and standard deviation.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Exercise 4 solutions</span>"
    ]
  },
  {
    "objectID": "exercise5_solutions.html",
    "href": "exercise5_solutions.html",
    "title": "Appendix D — Exercise 5 solutions",
    "section": "",
    "text": "D.1 Question 1\nLoad in the OBR’s household disposable income data (sheet 1.13). Split the period data into separate year and quarter variables, ensure that all variable names follow Tidyverse’s style guide. Name this object disposable_income.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Exercise 5 solutions</span>"
    ]
  },
  {
    "objectID": "exercise5_solutions.html#question-1",
    "href": "exercise5_solutions.html#question-1",
    "title": "Appendix D — Exercise 5 solutions",
    "section": "",
    "text": "Solution\nUsing the same approach as the housing market sheet, load the range of cells containing the data required, not including the variable names. Add variable names manually after selecting the variables required, then split the time variable into years and quarters.\n\ndisposable_income &lt;-\n  read_xlsx(\"data/Detailed_forecast_tables_Economy_March_2024.xlsx\",\n                               sheet = \"1.13\",range = \"B4:I51\", \n                               col_names = FALSE) %&gt;% \n  setNames(c(\"period\", \"labour_income\", \"emp_comp\", \"mixed_income\",\n             \"emp_social_cont\", \"nonlabour_inc\", \"net_tax_benefits\",\n             \"disposable_income\")) %&gt;% \n  mutate(year = as.numeric(str_sub(period, start = 1L, end = 4L)),\n         quarter = as.numeric(str_sub(period, start = -1L, end = -1L))) %&gt;% \n  select(-period)\n\nstr(disposable_income)\n\ntibble [48 × 9] (S3: tbl_df/tbl/data.frame)\n $ labour_income    : num [1:48] 196 197 197 198 199 ...\n $ emp_comp         : num [1:48] 208 210 210 211 212 ...\n $ mixed_income     : num [1:48] 25.4 26.2 25.8 25.6 25.8 ...\n $ emp_social_cont  : num [1:48] 38.2 38.6 38.9 38.6 38.6 ...\n $ nonlabour_inc    : num [1:48] 67 68.1 67.5 66.5 66.4 ...\n $ net_tax_benefits : num [1:48] 16.7 18.2 17.5 19 18.5 ...\n $ disposable_income: num [1:48] 279 284 282 284 284 ...\n $ year             : num [1:48] 2012 2012 2012 2012 2013 ...\n $ quarter          : num [1:48] 1 2 3 4 1 2 3 4 1 2 ...",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Exercise 5 solutions</span>"
    ]
  },
  {
    "objectID": "exercise5_solutions.html#question-2",
    "href": "exercise5_solutions.html#question-2",
    "title": "Appendix D — Exercise 5 solutions",
    "section": "D.2 Question 2",
    "text": "D.2 Question 2\nLoad the OBR’s national living wage data (sheet 1.14).\n\nSolution\nUsing the same approach as earlier, load the correct sheet in, selecting cells with data included. Variable names cannot begin with numbers, so rename them either manually, or by adding a prefix. The rename_with function allows us to rename variables by applying a function to them, in this case paste0 which combines elements in the function separated by commas:\n\nliving_wage &lt;- \n  read_xlsx(\"data/Detailed_forecast_tables_Economy_March_2024.xlsx\",\n            # Specify the sheet and range of cells to keep\n            sheet = \"1.14\", range = c(\"C4:K5\")) %&gt;% \n  # Rename variables by pasting the prefix \"year_\" to the original name\n  rename_with(~paste0(\"year_\", .x))",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Exercise 5 solutions</span>"
    ]
  },
  {
    "objectID": "exercise6_solutions.html",
    "href": "exercise6_solutions.html",
    "title": "Appendix E — Exercise 6 solutions",
    "section": "",
    "text": "E.1 Question\nCombine all three OBR datasets (housing market, disposable income and living wage) together to create one complete dataset, obr_data.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Exercise 6 solutions</span>"
    ]
  },
  {
    "objectID": "exercise6_solutions.html#question",
    "href": "exercise6_solutions.html#question",
    "title": "Appendix E — Exercise 6 solutions",
    "section": "",
    "text": "Solution\nUse full_join to combine the housing and disposable data by year and quarter, then pipe to apply full_join to the resulting data and add the living wage, joining by year. As there are multiple year rows in the housing and disposable income data, include the argument muliple = \"all\" to ensure the living wage variable is repeated for each quarter.\n\n# full join the housing and labour market data\nobr_data &lt;- full_join(housing_market, disposable_income, \n                      by = c(\"year\", \"quarter\")) %&gt;% \n  # join this data to the living wage\n  full_join(., living_wage_long, by = \"year\", multiple = \"all\")",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Exercise 6 solutions</span>"
    ]
  },
  {
    "objectID": "exercise7_solutions.html",
    "href": "exercise7_solutions.html",
    "title": "Appendix F — Exercise 7 solutions",
    "section": "",
    "text": "F.1 Question 1\nChoose an appropriate visualisation to investigate the change in household disposable income between 2012 and 2024. Comment on your findings.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Exercise 7 solutions</span>"
    ]
  },
  {
    "objectID": "exercise7_solutions.html#question-1",
    "href": "exercise7_solutions.html#question-1",
    "title": "Appendix F — Exercise 7 solutions",
    "section": "",
    "text": "Solution\nAn appropriate visualisation to investigate how a continuous variable changes across time is a line graph. This can be created using the geom_line function and requires the disposable income on the y-axis and a time variable on the x. The dataset does not currently contain an appropriate time variable that takes account of both the year and the quarter. Therefore, we will need to create one before we generate the plot:\n\nobr_data %&gt;% \n1  mutate(time = year + ((quarter - 1) * .25)) %&gt;%\n2  ggplot() +\n  geom_line(aes(x = time, y = disposable_income))\n\n\n1\n\nCreate a time variable that takes the value of the year for the first quarter, and then increases by .25 for each subsequent quarter\n\n2\n\nThe data has already been specified by piping it into the ggplot function\n\n\n\n\n\n\n\n\n\n\n\nDisposable income has increased over the past 12 years, with small decreases around 2020 and in the first period of 2024.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>F</span>  <span class='chapter-title'>Exercise 7 solutions</span>"
    ]
  },
  {
    "objectID": "exercise8_solutions.html",
    "href": "exercise8_solutions.html",
    "title": "Appendix G — Exercise 8 solution",
    "section": "",
    "text": "G.1 Question\nDisposable income is the sum of labour income, non-labour income, and net taxes and benefits. Decompose the time series created in Exercise 7 to show how the contribution of these elements to total disposable income varied across time.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Exercise 8 solution</span>"
    ]
  },
  {
    "objectID": "exercise8_solutions.html#question",
    "href": "exercise8_solutions.html#question",
    "title": "Appendix G — Exercise 8 solution",
    "section": "",
    "text": "Solution\nA stacked area chart (generated using geom_area) would allow us to visualise the total disposable income, broken down into the different income streams. The stacked area chart is created by layering each income value on top of one another, using a categorical variable representing income type to determine the area fill. This layout will require us to pivot the data to convert it into a long format.\n\nobr_data %&gt;% \n1  mutate(time = year + ((quarter - 1) * .25)) %&gt;%\n2  select(time, labour_income, nonlabour_inc,\n         net_tax_benefits) %&gt;%\n3  pivot_longer(cols = -time,\n4               names_to = \"income_type\",\n5               names_transform = list(income_type = as.factor),\n6               values_to = \"value\") %&gt;%\n  ggplot() +\n  geom_area(aes(x = time, y = value, fill = income_type))\n\n\n1\n\nCreate a time variable for the x-axis that accounts for both year and quarter\n\n2\n\nSelect variables required for the visualisation\n\n3\n\nPivot all variables apart from time\n\n4\n\nUse the current variable names to create a new variable named income_type\n\n5\n\nConvert the new income_type variable to factor (by default, R treats variable names as character)\n\n6\n\nUse the current income values to create a new variable named values",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>G</span>  <span class='chapter-title'>Exercise 8 solution</span>"
    ]
  },
  {
    "objectID": "exercise9_solutions.html",
    "href": "exercise9_solutions.html",
    "title": "Appendix H — Exercise 9 solution",
    "section": "",
    "text": "H.1 Question\nReturn to the visualisation showing the change in disposable income over time, decomposed into different income streams (labour, non-labour, and taxes and benefits). Adapt the visualisation to ensure it is accessible, compelling, and clear. This can include:\nSave this visualisation and add it into a Word document, along with a brief interpretation of the visualisation.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Exercise 9 solution</span>"
    ]
  },
  {
    "objectID": "exercise9_solutions.html#question",
    "href": "exercise9_solutions.html#question",
    "title": "Appendix H — Exercise 9 solution",
    "section": "",
    "text": "Adding an appropriate title and caption with data source information\nAdapting the colour scheme to make the differences more obvious\nAdding labels to commmunicate important findings to the reader\nAdjusting the theme to ensure text is large enough, values are clear but not overwhelmed by ‘chart junk’",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Exercise 9 solution</span>"
    ]
  },
  {
    "objectID": "exercise9_solutions.html#solution",
    "href": "exercise9_solutions.html#solution",
    "title": "Appendix H — Exercise 9 solution",
    "section": "Solution",
    "text": "Solution\nThere is no correct answer to this exercise, the solution provided here is a suggestion based on data visualisation principles covered in this chapter and my personal preference. I have added a title to make the visualisation clearer and a footnote with data source information. I have added the percentage of disposable income to each segment in 2012 and the last quarter of 2023 to make the changes more obvious.\nThe colours I have chosen to represent each income type cone from the R colour brewer palette Dark2 which is colour blind friendly and ensures the sections are distinct. Rather than including a legend, I have chosen to change the colour of the text in the subtitle to align with the income type. This is done using the ggtext package. You are not expected to know this but it is included as an idea for future work For more information and example code, visit the package website.\n\n1pacman::p_load(ggtext)\n\n2disp_income_long &lt;- obr_data %&gt;%\n  mutate(time = year + ((quarter - 1) * .25)) %&gt;% \n  select(time, labour_income, nonlabour_inc, \n         net_tax_benefits) %&gt;% \n  pivot_longer(cols = -time, \n               names_to = \"income_type\", \n               names_transform = list(income_type = as.factor), \n               values_to = \"value\")\n\n3perc_income &lt;- disp_income_long %&gt;%\n  filter(time == 2012 | time == 2023.75) %&gt;% \n  group_by(time) %&gt;% \n  mutate(perc_income = (value / sum(value)) * 100,\n         perc_clean = paste0(round(perc_income, 2), \"%\")) %&gt;% \n  ungroup()\n\nggplot(disp_income_long) +\n  geom_area(aes(x = time, y = value, fill = income_type)) +\n4  scale_fill_brewer(palette = \"Dark2\", guide = \"none\") +\n5  scale_x_continuous(breaks = seq(2012, 2022, by = 2)) +\n6  labs(title = \"Disposable income has increased between &lt;br&gt; 2012 and 2023\",\n       subtitle = \"Most disposable income comes from &lt;span style = 'color:#1b9e77;'&gt;labour&lt;/span&gt;, \n       followed by &lt;br&gt; &lt;span style = 'color:#7570b3;'&gt;non-labour&lt;/span&gt;\n7       , with the smallest proportion from &lt;span style = 'color:#d95f02;'&gt;net tax and benefits&lt;/span&gt;\",\n       x = \"Year\", y = \"Disposable income (£ billions)\",\n       caption = \"Data taken from the Office for Budget Responsibility (OBR) 2024 \\n economic and fiscal outlook\") +\n8  annotate(\"text\", x = 2012.75, y = 250,\n           label = filter(perc_income, \n                          time == 2012, \n                          income_type == \"labour_income\")$perc_clean) +\n  annotate(\"text\", x = 2012.75, y = 25, \n           label = filter(perc_income, \n                          time == 2012, \n                          income_type == \"nonlabour_inc\")$perc_clean) +\n  annotate(\"text\", x = 2012.75, y = 100, \n           label = filter(perc_income, \n                          time == 2012, \n                          income_type == \"net_tax_benefits\")$perc_clean) +\n  annotate(\"text\", x = 2023, y = 370, \n           label = filter(perc_income, \n                          time == 2023.75, \n                          income_type == \"labour_income\")$perc_clean) +\n  annotate(\"text\", x = 2023, y = 25, \n           label = filter(perc_income, \n                          time == 2023.75, \n                          income_type == \"nonlabour_inc\")$perc_clean) +\n  annotate(\"text\", x = 2023, y = 150, \n           label = filter(perc_income, \n                          time == 2023.75, \n                          income_type == \"net_tax_benefits\")$perc_clean) +\n9  theme_minimal() +\n  theme(plot.title = element_markdown(size = 16),\n        plot.subtitle = element_markdown(size = 12),\n        panel.grid.major.y = element_line(colour = \"grey45\"),\n        axis.title = element_text(size = 14),\n        axis.text = element_text(size = 12))\n\n\n1\n\nLoad in the ggtext package (if using)\n\n2\n\npivot the original data into the wide format required for this visualisation\n\n3\n\nBegin by calculating the percentage of disposable income that is made up of each different source. Create a ‘tidy’ version of this which can be added to the visualisation\n\n4\n\nUse the Dark2 palette for the area fills, determined by income type, and remove the legend (guide = \"none\")\n\n5\n\nAdapt the x-axis labels to show every 2 years\n\n6\n\nAdd an informative title\n\n7\n\nAdd a subtitle, showing each income type in the colour it is represented in the graph (this code is adapted from the ggtext webpage) as an alternative to a legend\n\n8\n\nAdd a text label showing the percentage of disposable income made up by each income type at the start and end of the period (the label is taken from the percentage we calculated above)\n\n9\n\nCheck that titles and text are large enough, make the y-axis gridlines bolder and easier to interpret.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>H</span>  <span class='chapter-title'>Exercise 9 solution</span>"
    ]
  }
]